// Copyright 2008 Simon Edwards <simon@simonzone.com>

//                 Generated by twine

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU Library General Public License as
// published by the Free Software Foundation; either version 2, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details

// You should have received a copy of the GNU Library General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.



%ModuleHeaderCode
//ctscc
#include <plasma/abstractrunner.h>
#include <plasma/animationdriver.h>
#include <plasma/animator.h>
#include <plasma/applet.h>
#include <plasma/scripting/appletscript.h>
#include <plasma/widgets/checkbox.h>
#include <plasma/widgets/combobox.h>
#include <plasma/configloader.h>
#include <plasma/containment.h>
#include <plasma/corona.h>
#include <plasma/datacontainer.h>
#include <plasma/dataengine.h>
#include <plasma/dataenginemanager.h>
#include <plasma/scripting/dataenginescript.h>
#include <plasma/delegate.h>
#include <plasma/dialog.h>
#include <plasma/widgets/flashinglabel.h>
#include <plasma/glapplet.h>
#include <plasma/widgets/groupbox.h>
#include <plasma/widgets/iconwidget.h>
#include <plasma/widgets/label.h>
#include <plasma/widgets/lineedit.h>
#include <plasma/widgets/meter.h>
#include <plasma/packagestructure.h>
#include <plasma/framesvg.h>
#include <plasma/widgets/pushbutton.h>
#include <plasma/widgets/radiobutton.h>
#include <plasma/runnercontext.h>
#include <plasma/runnermanager.h>
#include <plasma/scripting/runnerscript.h>
#include <plasma/scripting/scriptengine.h>
#include <plasma/widgets/signalplotter.h>
#include <plasma/svg.h>
#include <plasma/widgets/textedit.h>
#include <plasma/theme.h>
#include <plasma/uiloader.h>
#include <plasma/view.h>
#include <plasma/widgets/webview.h>
%End

namespace Plasma
{

class AbstractRunner : QObject
{
%TypeHeaderCode
#include <plasma/abstractrunner.h>
%End

public:

    enum Speed
    {
        SlowSpeed,
        NormalSpeed
    };


    enum Priority
    {
        LowestPriority,
        LowPriority,
        NormalPriority,
        HighPriority,
        HighestPriority
    };

    typedef QList<Plasma::AbstractRunner*> List;

    virtual void            match (Plasma::RunnerContext& context);
    void                    performMatch (Plasma::RunnerContext& context);
    bool                    hasRunOptions ();
    virtual void            createRunOptions (QWidget* widget);
    virtual void            run (const Plasma::RunnerContext& context, const Plasma::QueryMatch& action);
    Plasma::AbstractRunner::Speed  speed () const;
    Plasma::AbstractRunner::Priority  priority () const;
    Plasma::RunnerContext::Types  ignoredTypes () const;
    void                    setIgnoredTypes (Plasma::RunnerContext::Types types);
    QString                 name () const;
    QString                 id () const;
    QString                 description () const;
    const Plasma::Package*  package () const;
    virtual void            reloadConfiguration ();

protected:
    explicit                AbstractRunner (QObject* parent /TransferThis/ = 0, const QString& serviceId = QString());
                            AbstractRunner (QObject* parent /TransferThis/, const QVariantList& args);
    KConfigGroup            config () const;
    void                    setHasRunOptions (bool hasRunOptions);
    void                    setSpeed (Plasma::AbstractRunner::Speed newSpeed);
    void                    setPriority (Plasma::AbstractRunner::Priority newPriority);
    KService::List          serviceQuery (const QString& serviceType, const QString& constraint = QString()) const;
    QMutex*                 bigLock () const;
    void                    init ();

public:

//  Subclasses of QObject

%ConvertToSubClassCode

    sipClass = NULL;

    if (dynamic_cast<Plasma::AbstractRunner*>(sipCpp))
        sipClass = sipClass_Plasma_AbstractRunner;
    else if (dynamic_cast<Plasma::AnimationDriver*>(sipCpp))
        sipClass = sipClass_Plasma_AnimationDriver;
    else if (dynamic_cast<Plasma::Animator*>(sipCpp))
        sipClass = sipClass_Plasma_Animator;
    else if (dynamic_cast<Plasma::Applet*>(sipCpp))
        {
            sipClass = sipClass_Plasma_Applet;
            if (dynamic_cast<Plasma::Containment*>(sipCpp))
                sipClass = sipClass_Plasma_Containment;
            else if (dynamic_cast<Plasma::GLApplet*>(sipCpp))
                sipClass = sipClass_Plasma_GLApplet;
        }
    else if (dynamic_cast<Plasma::CheckBox*>(sipCpp))
        sipClass = sipClass_Plasma_CheckBox;
    else if (dynamic_cast<Plasma::ComboBox*>(sipCpp))
        sipClass = sipClass_Plasma_ComboBox;
    else if (dynamic_cast<Plasma::ConfigLoader*>(sipCpp))
        sipClass = sipClass_Plasma_ConfigLoader;
    else if (dynamic_cast<Plasma::Corona*>(sipCpp))
        sipClass = sipClass_Plasma_Corona;
    else if (dynamic_cast<Plasma::DataContainer*>(sipCpp))
        sipClass = sipClass_Plasma_DataContainer;
    else if (dynamic_cast<Plasma::DataEngine*>(sipCpp))
        sipClass = sipClass_Plasma_DataEngine;
    else if (dynamic_cast<Plasma::DataEngineManager*>(sipCpp))
        sipClass = sipClass_Plasma_DataEngineManager;
    else if (dynamic_cast<Plasma::Delegate*>(sipCpp))
        sipClass = sipClass_Plasma_Delegate;
    else if (dynamic_cast<Plasma::FlashingLabel*>(sipCpp))
        sipClass = sipClass_Plasma_FlashingLabel;
    else if (dynamic_cast<Plasma::GroupBox*>(sipCpp))
        sipClass = sipClass_Plasma_GroupBox;
    else if (dynamic_cast<Plasma::IconWidget*>(sipCpp))
        sipClass = sipClass_Plasma_IconWidget;
    else if (dynamic_cast<Plasma::Label*>(sipCpp))
        sipClass = sipClass_Plasma_Label;
    else if (dynamic_cast<Plasma::LineEdit*>(sipCpp))
        sipClass = sipClass_Plasma_LineEdit;
    else if (dynamic_cast<Plasma::Meter*>(sipCpp))
        sipClass = sipClass_Plasma_Meter;
    else if (dynamic_cast<Plasma::PackageStructure*>(sipCpp))
        sipClass = sipClass_Plasma_PackageStructure;
    else if (dynamic_cast<Plasma::PushButton*>(sipCpp))
        sipClass = sipClass_Plasma_PushButton;
    else if (dynamic_cast<Plasma::RadioButton*>(sipCpp))
        sipClass = sipClass_Plasma_RadioButton;
    else if (dynamic_cast<Plasma::RunnerContext*>(sipCpp))
        sipClass = sipClass_Plasma_RunnerContext;
    else if (dynamic_cast<Plasma::RunnerManager*>(sipCpp))
        sipClass = sipClass_Plasma_RunnerManager;
    else if (dynamic_cast<Plasma::ScriptEngine*>(sipCpp))
        {
            sipClass = sipClass_Plasma_ScriptEngine;
            if (dynamic_cast<Plasma::AppletScript*>(sipCpp))
                sipClass = sipClass_Plasma_AppletScript;
            else if (dynamic_cast<Plasma::DataEngineScript*>(sipCpp))
                sipClass = sipClass_Plasma_DataEngineScript;
            else if (dynamic_cast<Plasma::RunnerScript*>(sipCpp))
                sipClass = sipClass_Plasma_RunnerScript;
        }
    else if (dynamic_cast<Plasma::SignalPlotter*>(sipCpp))
        sipClass = sipClass_Plasma_SignalPlotter;
    else if (dynamic_cast<Plasma::Svg*>(sipCpp))
        {
            sipClass = sipClass_Plasma_Svg;
            if (dynamic_cast<Plasma::FrameSvg*>(sipCpp))
                sipClass = sipClass_Plasma_FrameSvg;
        }
    else if (dynamic_cast<Plasma::TextEdit*>(sipCpp))
        sipClass = sipClass_Plasma_TextEdit;
    else if (dynamic_cast<Plasma::Theme*>(sipCpp))
        sipClass = sipClass_Plasma_Theme;
    else if (dynamic_cast<Plasma::UiLoader*>(sipCpp))
        sipClass = sipClass_Plasma_UiLoader;
    else if (dynamic_cast<Plasma::View*>(sipCpp))
        sipClass = sipClass_Plasma_View;
    else if (dynamic_cast<Plasma::WebView*>(sipCpp))
        sipClass = sipClass_Plasma_WebView;
%End

};   // AbstractRunner

};   // Plasma


