// Copyright 2010 Simon Edwards <simon@simonzone.com>

//                 Generated by twine2

// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU Library General Public License as
// published by the Free Software Foundation; either version 2, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details

// You should have received a copy of the GNU Library General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

namespace Nepomuk
{
namespace Query
{
class Term
{
%TypeHeaderCode
#include <term.h>
%End

public:
    enum Type
    {
        Invalid,
        Literal,
        Resource,
        And,
        Or,
        Comparison,
        ResourceType,
        Negation
    };
                            Term ();
                            Term (const Nepomuk::Query::Term& other);
    ~Term ();
    bool                    isValid () const;
    Nepomuk::Query::Term::Type  type () const;
    bool                    isLiteralTerm () const;
    bool                    isResourceTerm () const;
    bool                    isNegationTerm () const;
    bool                    isAndTerm () const;
    bool                    isOrTerm () const;
    bool                    isComparisonTerm () const;
    bool                    isResourceTypeTerm () const;
    Nepomuk::Query::LiteralTerm  toLiteralTerm () const;
    Nepomuk::Query::ResourceTerm  toResourceTerm () const;
    Nepomuk::Query::NegationTerm  toNegationTerm () const;
    Nepomuk::Query::AndTerm  toAndTerm () const;
    Nepomuk::Query::OrTerm  toOrTerm () const;
    Nepomuk::Query::ComparisonTerm  toComparisonTerm () const;
    Nepomuk::Query::ResourceTypeTerm  toResourceTypeTerm () const;
    Nepomuk::Query::LiteralTerm&  toLiteralTerm ();
    Nepomuk::Query::ResourceTerm&  toResourceTerm ();
    Nepomuk::Query::NegationTerm&  toNegationTerm ();
    Nepomuk::Query::AndTerm&  toAndTerm ();
    Nepomuk::Query::OrTerm&  toOrTerm ();
    Nepomuk::Query::ComparisonTerm&  toComparisonTerm ();
    Nepomuk::Query::ResourceTypeTerm&  toResourceTypeTerm ();
    bool                    operator == (const Nepomuk::Query::Term& term) const;
    QDebug                  operator << (QDebug) const;
protected:
                            Term (TermPrivate*);
%ConvertToSubClassCode
    // CTSCC for subclasses of 'Term'
    sipType = NULL;

    if (dynamic_cast<Nepomuk::Query::GroupTerm*>(sipCpp))
        {
        sipType = sipType_Nepomuk_Query_GroupTerm;
        if (dynamic_cast<Nepomuk::Query::AndTerm*>(sipCpp))
            sipType = sipType_Nepomuk_Query_AndTerm;
        else if (dynamic_cast<Nepomuk::Query::OrTerm*>(sipCpp))
            sipType = sipType_Nepomuk_Query_OrTerm;
        }
    else if (dynamic_cast<Nepomuk::Query::LiteralTerm*>(sipCpp))
        sipType = sipType_Nepomuk_Query_LiteralTerm;
    else if (dynamic_cast<Nepomuk::Query::ResourceTerm*>(sipCpp))
        sipType = sipType_Nepomuk_Query_ResourceTerm;
    else if (dynamic_cast<Nepomuk::Query::ResourceTypeTerm*>(sipCpp))
        sipType = sipType_Nepomuk_Query_ResourceTypeTerm;
    else if (dynamic_cast<Nepomuk::Query::SimpleTerm*>(sipCpp))
        {
        sipType = sipType_Nepomuk_Query_SimpleTerm;
        if (dynamic_cast<Nepomuk::Query::ComparisonTerm*>(sipCpp))
            sipType = sipType_Nepomuk_Query_ComparisonTerm;
        else if (dynamic_cast<Nepomuk::Query::NegationTerm*>(sipCpp))
            sipType = sipType_Nepomuk_Query_NegationTerm;
        }
%End
};
uint                    qHash (const Nepomuk::Query::Term&);
};
};
//ig Nepomuk::Query::TermPrivate*  clone ();
//ig QDebug                  operator << (QDebug, const Nepomuk::Query::Term&);
%ModuleHeaderCode
//ctscc
#include <andterm.h>
#include <comparisonterm.h>
#include <groupterm.h>
#include <literalterm.h>
#include <negationterm.h>
#include <orterm.h>
#include <resourceterm.h>
#include <resourcetypeterm.h>
#include <simpleterm.h>
#include <term.h>
%End
