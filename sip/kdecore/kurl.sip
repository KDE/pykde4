//
//     Copyright 2008 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2007 Jim Bublitz also apply

//                 Generated by twine

// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.



%ModuleHeaderCode
//ctscc
#include <kurl.h>
%End

class KUrl : QUrl
{
%TypeHeaderCode
#include <kurl.h>
%End


public:
    typedef QMap<QString,QString> MetaDataMap;


    enum MimeDataFlags
    {
        DefaultMimeDataFlags,
        NoTextExport
    };


    class List
    {

    public:
                                List ();
                                List (const KUrl& url);
                                List (const QStringList& list);
                                List (const QList<KUrl>& list);
        QStringList             toStringList () const;
        void                    populateMimeData (QMimeData* mimeData, const KUrl::MetaDataMap& metaData = KUrl::MetaDataMap(), KUrl::MimeDataFlags flags = KUrl::DefaultMimeDataFlags) const;
        void                    populateMimeData (const KUrl::List& mostLocalUrls, QMimeData* mimeData, const KUrl::MetaDataMap& metaData = KUrl::MetaDataMap(), KUrl::MimeDataFlags flags = KUrl::DefaultMimeDataFlags) const;
        static bool             canDecode (const QMimeData* mimeData);
        static QStringList      mimeDataTypes ();
        static KUrl::List       fromMimeData (const QMimeData* mimeData, KUrl::MetaDataMap* metaData = 0);

//force
        int                     __len__ ();
%MethodCode
//returns (int)
    Py_BEGIN_ALLOW_THREADS
    sipRes = sipCpp -> count();
    Py_END_ALLOW_THREADS
%End

        void                    __setitem__ (int, const KUrl&);
%MethodCode
//takes index | (int) | value | (KUrl)
    int len;

    len = sipCpp -> count();

    if ((a0 = sipConvertFromSequenceIndex(a0,len)) < 0)
        sipIsErr = 1;
    else
        (*sipCpp)[a0] = *a1;
%End

        void                    __setitem__ (SIP_PYSLICE, const KUrl::List&);
%MethodCode
//takes range | (a Python slice) | urlList | (KUrl.List)
    SIP_SSIZE_T len, start, stop, step, slicelength, i;

    len = sipCpp -> count();

    if (sipConvertFromSliceObject(a0,len,&start,&stop,&step,&slicelength) < 0)
        sipIsErr = 1;
    else
    {
        int vlen = a1 -> count();
        if (vlen != slicelength)
        {
            sipBadLengthForSlice(vlen,slicelength);
            sipIsErr = 1;
        }
        else
        {
            KUrl::List::ConstIterator it = a1 -> begin();
            for (i = 0; i < slicelength; ++i)
            {
                (*sipCpp)[start] = *it;
                start += step;
                ++it;
            }
        }
    }
%End

        void                    __delitem__ (int);
%MethodCode
//takes index | (int)
    int len;

    len = sipCpp -> count();

    if ((a0 = sipConvertFromSequenceIndex(a0,len)) < 0)
        sipIsErr = 1;
    else
        sipCpp -> removeAt(a0);
%End

        void                    __delitem__ (SIP_PYSLICE);
%MethodCode
//takes range | (a Python slice)
    SIP_SSIZE_T len, start, stop, step, slicelength, i;

    len = sipCpp -> count();
    if (sipConvertFromSliceObject(a0,len,&start,&stop,&step,&slicelength) < 0)
        sipIsErr = 1;
    else
        for (i = 0; i < slicelength; ++i)
        {
            sipCpp -> removeAt(start);
            start += step - 1;
        }
%End

        KUrl                    operator [] (int);
%MethodCode
//returns (KUrl)
//takes index | (int)
    int len;

    len = sipCpp -> count();

    if ((a0 = sipConvertFromSequenceIndex(a0,len)) < 0)
        sipIsErr = 1;
    else
        sipRes = new KUrl((*sipCpp)[a0]);
%End

        KUrl::List              operator [] (SIP_PYSLICE);
%MethodCode
//returns (KUrl.List)
//takes range | (a Python slice)
    SIP_SSIZE_T len, start, stop, step, slicelength, i;

    len = sipCpp -> count();

    if (sipConvertFromSliceObject(a0,len,&start,&stop,&step,&slicelength) < 0)
        sipIsErr = 1;
    else
    {
        sipRes = new KUrl::List();

        for (i = 0; i < slicelength; ++i)
        {
            (*sipRes) += (*sipCpp)[start];
            start += step;
        }
    }
%End

        KUrl::List              operator + (const KUrl::List&);
%MethodCode
//returns (KUrl.List)
//takes listToAdd | (KUrl.List)
    Py_BEGIN_ALLOW_THREADS
//    sipRes = new KUrl::List((const KUrl::List&)((*sipCpp) + *a0));
    sipRes = new KUrl::List (*sipCpp);
    (*sipRes) += (*a0);
    Py_END_ALLOW_THREADS
%End

        KUrl::List&             operator += (const KUrl::List&);
        KUrl::List              operator * (int);
%MethodCode
sipRes = new KUrl::List();

    for (int i = 0; i < a0; ++i)
        (*sipRes) += (*sipCpp);
%End

        KUrl::List&             operator *= (int);
%MethodCode
//returns (KUrl.List)
//takes val | (int)
    KUrl::List orig(*sipCpp);

    sipCpp -> clear();

    for (int i = 0; i < a0; ++i)
        (*sipCpp) += orig;
%End

        bool                    operator == (const KUrl::List&);
        bool                    operator != (const KUrl::List&);
        int                     __contains__ (KUrl);
%MethodCode
//returns (bool)
//takes a0 | (KUrl)
        // It looks like you can't assign QBool to int.
        sipRes = bool(sipCpp->contains(*a0));
%End

//end

    };   // List


public:
                            KUrl ();
                            KUrl (const QString& urlOrPath);
    explicit                KUrl (const char* urlOrPath);
    explicit                KUrl (const QByteArray& urlOrPath);
                            KUrl (const KUrl& u);
                            KUrl (const QUrl& u);
                            KUrl (const KUrl& _baseurl, const QString& _rel_url);
    QString                 protocol () const;
    void                    setProtocol (const QString& proto);
    QString                 user () const;
    void                    setUser (const QString& user);
    bool                    hasUser () const;
    QString                 pass () const /PyName=pass_/;
    void                    setPass (const QString& pass);
    bool                    hasPass () const;
    bool                    hasHost () const;

    enum AdjustPathOption
    {
        RemoveTrailingSlash,
        LeaveTrailingSlash,
        AddTrailingSlash
    };

    QString                 path (KUrl::AdjustPathOption trailing = KUrl::LeaveTrailingSlash) const;
    QString                 toLocalFile (KUrl::AdjustPathOption trailing = KUrl::LeaveTrailingSlash) const;
    void                    setPath (const QString& path);
    bool                    hasPath () const;

    enum CleanPathOption
    {
        SimplifyDirSeparators,
        KeepDirSeparators
    };

    typedef QFlags<KUrl::CleanPathOption> CleanPathOptions;

    void                    cleanPath (const KUrl::CleanPathOption& options = KUrl::SimplifyDirSeparators);
    void                    adjustPath (KUrl::AdjustPathOption trailing);
    void                    setEncodedPathAndQuery (const QString& _txt);

    enum EncodedPathAndQueryOption
    {
        PermitEmptyPath,
        AvoidEmptyPath
    };

    typedef QFlags<KUrl::EncodedPathAndQueryOption> EncodedPathAndQueryOptions;

    QString                 encodedPathAndQuery (KUrl::AdjustPathOption trailing = KUrl::LeaveTrailingSlash, const KUrl::EncodedPathAndQueryOptions& options = KUrl::PermitEmptyPath) const;
    void                    setQuery (const QString& query);
    QString                 query () const;
    QString                 ref () const;
    void                    setRef (const QString& fragment);
    bool                    hasRef () const;
    QString                 htmlRef () const;
    QString                 encodedHtmlRef () const;
    void                    setHTMLRef (const QString& _ref);
    bool                    hasHTMLRef () const;
    bool                    isLocalFile () const;
    void                    setFileEncoding (const QString& encoding);
    QString                 fileEncoding () const;
    bool                    hasSubUrl () const;
    void                    addPath (const QString& txt);

    enum QueryItemsOption
    {
        CaseInsensitiveKeys
    };

    typedef QFlags<KUrl::QueryItemsOption> QueryItemsOptions;

    QMap<QString,QString>   queryItems (const KUrl::QueryItemsOptions& options = 0) const;
    QString                 queryItem (const QString& item) const;
    void                    addQueryItem (const QString& _item, const QString& _value);
    void                    setFileName (const QString& _txt);

    enum DirectoryOption
    {
        ObeyTrailingSlash,
        AppendTrailingSlash,
        IgnoreTrailingSlash
    };

    typedef QFlags<KUrl::DirectoryOption> DirectoryOptions;

    QString                 fileName (const KUrl::DirectoryOptions& options = KUrl::IgnoreTrailingSlash) const;
    QString                 directory (const KUrl::DirectoryOptions& options = KUrl::IgnoreTrailingSlash) const;
    void                    setDirectory (const QString& dir);
    bool                    cd (const QString& _dir);
    QString                 url (KUrl::AdjustPathOption trailing = KUrl::LeaveTrailingSlash) const;
    QString                 prettyUrl (KUrl::AdjustPathOption trailing = KUrl::LeaveTrailingSlash) const;
    QString                 pathOrUrl () const;
    QString                 toMimeDataString () const;
    KUrl                    upUrl () const;
    bool                    operator == (const KUrl& _u) const;
    bool                    operator == (const QString& _u) const;
    bool                    operator != (const KUrl& _u) const;
    bool                    operator != (const QString& _u) const;
    bool                    cmp (const KUrl& u, bool ignore_trailing = 0) const;

    enum EqualsOption
    {
        CompareWithoutTrailingSlash,
        CompareWithoutFragment
    };

    typedef QFlags<KUrl::EqualsOption> EqualsOptions;

    bool                    equals (const KUrl& u, const KUrl::EqualsOptions& options = 0) const;
    bool                    isParentOf (const KUrl& u) const;
    static KUrl::List       split (const QString& _url);
    static KUrl::List       split (const KUrl& _url);
    static KUrl             join (const KUrl::List& _list);
    static KUrl             fromPath (const QString& text);
    static KUrl             fromPathOrUrl (const QString& text);
    static KUrl             fromMimeDataByteArray (const QByteArray& str);
    void                    populateMimeData (QMimeData* mimeData, const KUrl::MetaDataMap& metaData = KUrl::MetaDataMap(), KUrl::MimeDataFlags flags = KUrl::DefaultMimeDataFlags) const;
    static QString          encode_string (const QString& str);
    static QString          encode_string_no_slash (const QString& str);
    static QString          decode_string (const QString& str);
    static bool             isRelativeUrl (const QString& _url);
    static QString          relativeUrl (const KUrl& base_url, const KUrl& url);
    static QString          relativePath (const QString& base_dir, const QString& path, bool* isParent /Out/ = 0);

public:

//  Subclasses of QUrl

%ConvertToSubClassCode

    sipClass = NULL;

    if (dynamic_cast<KUrl*>(sipCpp))
        sipClass = sipClass_KUrl;
%End

};   // KUrl

bool                    urlcmp (const QString& _url1, const QString& _url2);
bool                    urlcmp (const QString& _url1, const QString& _url2, const KUrl::EqualsOptions& options);
uint                    qHash (const QString& key);
uint                    qHash (const KUrl& kurl);
%ModuleHeaderCode
#include <kurl.h>
%End

%ModuleHeaderCode
#include <kurl.h>
%End




