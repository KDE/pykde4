//
//     Copyright 2007 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2006 Jim Bublitz also apply


//                 Generated by preSip
//            PyKDE4 module kdecore  version KDE 3.92.0


// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


class KCmdLineOptions
{
%TypeHeaderCode
#include <kcmdlineargs.h>
extern char **pyArgvToC(PyObject *argvlist,int *argcp);
extern void updatePyArgv(PyObject *argvlist,int argc,char **argv);
%End


public:
                         KCmdLineOptions ();
                         KCmdLineOptions (const KCmdLineOptions&);
    KCmdLineOptions&     add (const QByteArray&, const KLocalizedString& = KLocalizedString (), const QByteArray& = QByteArray ());
    KCmdLineOptions&     add (const KCmdLineOptions&);

};  // class KCmdLineOptions


class KCmdLineArgs
{
%TypeHeaderCode
#include <kcmdlineargs.h>
#include <qapplication.h>
extern char **pyArgvToC(PyObject *argvlist,int *argcp);
extern void updatePyArgv(PyObject *argvlist,int argc,char **argv);
%End


public:

    enum StdCmdLineArg
    {
        CmdLineArgQt, 
        CmdLineArgKDE, 
        CmdLineArgsMask, 
        CmdLineArgNone, 
        Reserved
    };

    typedef QFlags<KCmdLineArgs::StdCmdLineArg> StdCmdLineArgs;
    static void          init (SIP_PYLIST, const QByteArray&, const QByteArray&, const KLocalizedString&, const QByteArray&, const KLocalizedString& = KLocalizedString (), int = 3) [void (int, char**, const QByteArray&, const QByteArray&, const KLocalizedString&, const QByteArray&, const KLocalizedString& = KLocalizedString (), KCmdLineArgs::StdCmdLineArgs = 3)];
%MethodCode
//returns (void)
//takes Python list | (list) | appname | (QByteArray) | catalog | (QByteArray) | programName | (KLocalizedString) | version | (QByteArray) | description | (KLocalizedString - default = KLocalizedString ()) | stdargs | (KCmdLineArgs::StdCmdLineArgs)
    KCmdLineArgs::StdCmdLineArgs cmdLineArgs = (KCmdLineArgs::StdCmdLineArgs) a6;
    int argc, nargc;
    char **argv;
      
    // Convert the list.

    if ((argv = pyArgvToC(a0, &argc)) == NULL)
        return NULL;

    // Create it now the arguments are right.
    nargc = argc;

    Py_BEGIN_ALLOW_THREADS
    KCmdLineArgs::init (nargc, argv, *a1, *a2, *a3, *a4, *a5, cmdLineArgs);
    Py_END_ALLOW_THREADS

    // Now modify the original list.

    updatePyArgv (a0, argc, argv);
%End

    static void          init (SIP_PYLIST, const KAboutData*, int = 3) [void (int, char**, const KAboutData*, KCmdLineArgs::StdCmdLineArgs = 3)];
%MethodCode
//returns (void)
//takes Python list | (list) | about | (KAboutData) | stdargs | (KCmdLineArgs::StdCmdLineArgs - default = StdCmdLineArgs (CmdLineArgQt or CmdLineArgKDE ))
    KCmdLineArgs::StdCmdLineArgs cmdLineArgs = (KCmdLineArgs::StdCmdLineArgs) a2;
    int argc, nargc;
    char **argv;
       
    // Convert the list.

    if ((argv = pyArgvToC(a0, &argc)) == NULL)
        return NULL;

    // Create it now the arguments are right.
    nargc = argc;

    Py_BEGIN_ALLOW_THREADS
    KCmdLineArgs::init (nargc, argv, a1, cmdLineArgs);
    Py_END_ALLOW_THREADS

    // Now modify the original list.

    updatePyArgv (a0, argc, argv);
%End

    static void          init (const KAboutData*);
    static void          addStdCmdLineOptions (KCmdLineArgs::StdCmdLineArgs);
    static void          addCmdLineOptions (const KCmdLineOptions&, const KLocalizedString& = KLocalizedString (), const QByteArray& = QByteArray (), const QByteArray& = QByteArray ());
    static KCmdLineArgs* parsedArgs (const QByteArray& = QByteArray ());
    static QString       cwd ();
    static QString       appName ();
    static void          usage (const QByteArray& = QByteArray ());
    static void          usageError (const QString&);
    static void          enable_i18n ();
    QString              getOption (const QByteArray&) const;
    QStringList          getOptionList (const QByteArray&) const;
    bool                 isSet (const QByteArray&) const;
    int                  count ();
    QString              arg (int) const;
    KUrl                 url (int) const;
    static KUrl          makeURL (const QByteArray&);
    static void          setCwd (const QByteArray&);
    void                 clear ();
    static void          reset ();
    static void          loadAppArgs (QDataStream&);
    static void          addTempFileOption ();
    static bool          isTempFileSet ();
//ig     static int&          qtArgc ();
//ig     static char**        qtArgv ();
    static const KAboutData* aboutData ();

protected:
                         KCmdLineArgs (const KCmdLineOptions&, const KLocalizedString&, const QByteArray&);
                         ~KCmdLineArgs ();

};  // class KCmdLineArgs



%ModuleCode
#include <string.h>

// Convert a Python argv list to a conventional C argc count and argv array.
char **pyArgvToC(PyObject *argvlist,int *argcp)
{
    int argc;
    char **argv;

    argc = PyList_Size(argvlist);

    // Allocate space for two copies of the argument pointers, plus the
    // terminating NULL.
    if ((argv = (char **)sipMalloc(2 * (argc + 1) * sizeof (char *))) == NULL)
        return NULL;

    // Convert the list.
    for (int a = 0; a < argc; ++a)
    {
        char *arg;

        // Get the argument and allocate memory for it.
        if ((arg = PyString_AsString(PyList_GetItem(argvlist,a))) == NULL ||
            (argv[a] = (char *)sipMalloc(strlen(arg) + 1)) == NULL)
            return NULL;

        // Copy the argument and save a pointer to it.
        strcpy(argv[a],arg);
        argv[a + argc + 1] = argv[a];
    }

    argv[argc + argc + 1] = argv[argc] = NULL;

    *argcp = argc;

    return argv;
}


// Remove arguments from the Python argv list that have been removed from the
// C argv array.
void updatePyArgv(PyObject *argvlist,int argc,char **argv)
{
    for (int a = 0, na = 0; a < argc; ++a)
    {
        // See if it was removed.
        if (argv[na] == argv[a + argc + 1])
            ++na;
        else
            PyList_SetSlice(argvlist,na,na + 1,NULL);
    }
}
%End
