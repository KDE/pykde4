//
//     Copyright 2007 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2006 Jim Bublitz also apply


//                 Generated by preSip
//            PyKDE4 module kdeui  version KDE 3.92.0


// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

%ModuleHeaderCode
//ctscc
#include <kcombobox.h>
#include <khistorycombobox.h>
#include <klineedit.h>
#include <klistwidgetsearchline.h>
#include <ktreewidgetsearchline.h>
#include <krestrictedline.h>
%End


class KCompletion : QObject
{
%TypeHeaderCode
#include <kcompletion.h>
%End


public:

    enum CompOrder
    {
        Sorted, 
        Insertion, 
        Weighted
    };

                         KCompletion ();
    virtual QString      makeCompletion (const QString&);
    QStringList          substringCompletion (const QString&) const;
    QString              previousMatch ();
    QString              nextMatch ();
    virtual const QString& lastMatch () const;
    QStringList          items () const;
    bool                 isEmpty () const;
    virtual void         setCompletionMode (KGlobalSettings::Completion);
    KGlobalSettings::Completion completionMode () const;
    virtual void         setOrder (KCompletion::CompOrder);
    KCompletion::CompOrder order () const;
    virtual void         setIgnoreCase (bool);
    bool                 ignoreCase () const;
    QStringList          allMatches ();
    QStringList          allMatches (const QString&);
//ig     KCompletionMatches   allWeightedMatches ();
//ig     KCompletionMatches   allWeightedMatches (const QString&);
    virtual void         setSoundsEnabled (bool);
    bool                 soundsEnabled () const;
    bool                 hasMultipleMatches () const;

public slots:
    void                 slotMakeCompletion (const QString&);
    void                 slotPreviousMatch ();
    void                 slotNextMatch ();
    void                 insertItems (const QStringList&);
    virtual void         setItems (const QStringList&);
    void                 addItem (const QString&);
    void                 addItem (const QString&, uint);
    void                 removeItem (const QString&);
    virtual void         clear ();

signals:
    void                 match (const QString&);
    void                 matches (const QStringList&);
    void                 multipleMatches ();

protected:
    virtual void         postProcessMatch (QString*) const;
    virtual void         postProcessMatches (QStringList*) const;
//ig     virtual void         postProcessMatches (KCompletionMatches*) const;
private:
                         KCompletion (const KCompletion&) [()];
};  // class KCompletion


//ig class KCompletionMatches : KCompletionMatchesList;


class KCompletionBase
{
%TypeHeaderCode
#include <kcompletion.h>
%End


public:

    enum KeyBindingType
    {
        TextCompletion, 
        PrevCompletionMatch, 
        NextCompletionMatch, 
        SubstringCompletion
    };

    typedef QMap<KCompletionBase::KeyBindingType, KShortcut> KeyBindingMap;
                         KCompletionBase ();
    KCompletion*         completionObject (bool = 1);
    virtual void         setCompletionObject (KCompletion*, bool = 1);
    virtual void         setHandleSignals (bool);
    bool                 isCompletionObjectAutoDeleted () const;
    void                 setAutoDeleteCompletionObject (bool);
    void                 setEnableSignals (bool);
    bool                 handleSignals () const;
    bool                 emitSignals () const;
    virtual void         setCompletionMode (KGlobalSettings::Completion);
    KGlobalSettings::Completion completionMode () const;
    bool                 setKeyBinding (KCompletionBase::KeyBindingType, const KShortcut&);
    KShortcut            getKeyBinding (KCompletionBase::KeyBindingType) const;
    void                 useGlobalKeyBindings ();
    virtual void         setCompletedText (const QString&)  = 0;
    virtual void         setCompletedItems (const QStringList&, bool = 1)  = 0;
    KCompletion*         compObj () const;

protected:
    KCompletionBase::KeyBindingMap getKeyBindings () const;
    void                 setDelegate (KCompletionBase*);
    KCompletionBase*     delegate () const;

protected:
//igx     virtual void         virtual_hook (int, void*);

// Subclasses for KCompletionBase

public:
%ConvertToSubClassCode

    if (dynamic_cast<KComboBox*>(sipCpp))
    {
        sipClass = sipClass_KComboBox;
        if (dynamic_cast<KHistoryComboBox*>(sipCpp))
            sipClass = sipClass_KHistoryComboBox;
    }
    else if (dynamic_cast<KLineEdit*>(sipCpp))
    {
        sipClass = sipClass_KLineEdit;
        if (dynamic_cast<KListWidgetSearchLine*>(sipCpp))
            sipClass = sipClass_KListWidgetSearchLine;
        else if (dynamic_cast<KTreeWidgetSearchLine*>(sipCpp))
            sipClass = sipClass_KTreeWidgetSearchLine;
        else if (dynamic_cast<KRestrictedLine*>(sipCpp))
            sipClass = sipClass_KRestrictedLine;
    }
    else
        sipClass = NULL;
%End
private:
                         KCompletionBase (const KCompletionBase&) [()];

};  // class KCompletionBase

//ig typedef KSortableList<QString> KCompletionMatchesList;


%MappedType QMap<KCompletionBase::KeyBindingType,KShortcut>
{
%TypeHeaderCode
#include <qmap.h>
%End

%ConvertFromTypeCode
    // Create the dictionary.
    PyObject *d = PyDict_New();

    if (!d)
        return NULL;

    // Set the dictionary elements.
    QMap<KCompletionBase::KeyBindingType, KShortcut>::const_iterator i = sipCpp->constBegin();

    while (i != sipCpp->constEnd())
    {
        KShortcut *t = new KShortcut(i.value());

        PyObject *kobj = PyInt_FromLong((int)i.key());
        PyObject *tobj = sipConvertFromNewInstance(t, sipClass_KShortcut, sipTransferObj);

        if (kobj == NULL || tobj == NULL || PyDict_SetItem(d, kobj, tobj) < 0)
        {
            Py_DECREF(d);

            if (kobj)
                Py_DECREF(kobj);

            if (tobj)
                Py_DECREF(tobj);
            else
                delete t;

            return NULL;
        }

        Py_DECREF(kobj);
        Py_DECREF(tobj);

        ++i;
    }

    return d;
%End

%ConvertToTypeCode
    PyObject *kobj, *tobj;
    SIP_SSIZE_T i = 0;

    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
    {
        if (!PyDict_Check(sipPy))
            return 0;

        while (PyDict_Next(sipPy, &i, &kobj, &tobj))
            if (!sipCanConvertToInstance(tobj, sipClass_KShortcut, SIP_NOT_NONE))
                return 0;

        return 1;
    }

    QMap<KCompletionBase::KeyBindingType, KShortcut> *qm = new QMap<KCompletionBase::KeyBindingType, KShortcut>;
 
    while (PyDict_Next(sipPy, &i, &kobj, &tobj))
    {
        int state;
        int k = PyInt_AsLong(kobj);
        KShortcut *t = reinterpret_cast<KShortcut *>(sipConvertToInstance(tobj, sipClass_KShortcut, sipTransferObj, SIP_NOT_NONE, &state, sipIsErr));
 
        if (*sipIsErr)
        {
            sipReleaseInstance(t, sipClass_KShortcut, state);

            delete qm;
            return 0;
        }

        qm->insert((KCompletionBase::KeyBindingType)k, *t);

        sipReleaseInstance(t, sipClass_KShortcut, state);
    }
 
    *sipCppPtr = qm;
 
    return sipGetState(sipTransferObj);
%End
};


