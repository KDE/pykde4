<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>Nepomuk.Query.QueryServiceClient</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="../common/doxygen.css" />
  <link rel="stylesheet" media="screen" type="text/css" title="KDE Colors" href="../common/kde.css" />
</head>
<body>
<div id="container">
<div id="header">
  <div id="header_top">
    <div>
      <div>
        <img alt ="" src="../common/top-kde.jpg"/>
        KDE 4.7 PyKDE API Reference
      </div>
    </div>
  </div>
  <div id="header_bottom">
    <div id="location">
      <ul>
        <li>KDE's Python API</li>
      </ul>
    </div>

    <div id="menu">
      <ul>
        <li><a href="../modules.html">Overview</a></li>
<li><a href="http://techbase.kde.org/Development/Languages/Python">PyKDE Home</a></li>
<li><a href="http://kde.org/family/">Sitemap</a></li>
<li><a href="http://kde.org/contact/">Contact Us</a></li>
</ul>
    </div>
  </div>
</div>

<div id="body_wrapper">
<div id="body">
<div id="right">
<div class="content">
<div id="main">
<div class="clearer">&nbsp;</div>

<h1>QueryServiceClient Class Reference</h1>
<code>from PyKDE4.nepomuk import *</code>
<p>
Inherits: QObject<br />

Namespace: <a href="../nepomuk/Nepomuk.Query.html">Nepomuk.Query</a><br />
<h2>Detailed Description</h2>

<p>\class QueryServiceClient queryserviceclient.h Nepomuk/Query/QueryServiceClient
</p>
<p>
Convenience frontend to the %Nepomuk Query DBus Service
</p>
<p>
The QueryServiceClient provides an easy way to access the %Nepomuk Query Service
without having to deal with any communication details. By default it monitors
queries for changes.
</p>
<p>
Usage is simple: Create an instance of the client for each search you want to
track. One instance may also be reused for subsequent queries if further updates
of the persistent query are not necessary.
</p>
<p>
For quick queries which do not require any updates one of the static query methods
can be used: syncQuery(), syncSparqlQuery(), or syncDesktopQuery().
</p>
<p>

<dl class="author" compact><dt><b>Author:</b></dt><dd> Sebastian Trueg &lt;trueg@kde.org&gt; </dd></dl>
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.4
</dd></dl>
</p>
<table border="0" cellpadding="0" cellspacing="0"><tr><td colspan="2"><br><h2>Signals</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#entriesRemoved">entriesRemoved</a> ([QUrl] entries)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#error">error</a> (QString errorMessage)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#finishedListing">finishedListing</a> ()</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#newEntries">newEntries</a> ([<a href="../nepomuk/Nepomuk.Query.Result.html">Nepomuk.Query.Result</a>] entries)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#resultCount">resultCount</a> (int count)</td></tr>
<tr><td colspan="2"><br><h2>Methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#QueryServiceClient">__init__</a> (self, QObject parent=0)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#blockingDesktopQuery">blockingDesktopQuery</a> (self, QString query)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#blockingQuery">blockingQuery</a> (self, <a href="../nepomuk/Nepomuk.Query.Query.html">Nepomuk.Query.Query</a> query)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#blockingSparqlQuery">blockingSparqlQuery</a> (self, QString query, {QString:<a href="../nepomuk/Nepomuk.Types.Property.html">Nepomuk.Types.Property</a>} requestPropertyMap=Nepomuk.Query.RequestPropertyMap())</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#close">close</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#desktopQuery">desktopQuery</a> (self, QString query)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#errorMessage">errorMessage</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#isListingFinished">isListingFinished</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#query">query</a> (self, <a href="../nepomuk/Nepomuk.Query.Query.html">Nepomuk.Query.Query</a> query)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#sparqlQuery">sparqlQuery</a> (self, QString query, {QString:<a href="../nepomuk/Nepomuk.Types.Property.html">Nepomuk.Types.Property</a>} requestPropertyMap=Nepomuk.Query.RequestPropertyMap())</td></tr>
<tr><td colspan="2"><br><h2>Static Methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#serviceAvailable">serviceAvailable</a> ()</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">[<a href="../nepomuk/Nepomuk.Query.Result.html">Nepomuk.Query.Result</a>]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#syncDesktopQuery">syncDesktopQuery</a> (QString query, bool ok=0)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">[<a href="../nepomuk/Nepomuk.Query.Result.html">Nepomuk.Query.Result</a>]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#syncQuery">syncQuery</a> (<a href="../nepomuk/Nepomuk.Query.Query.html">Nepomuk.Query.Query</a> query, bool ok=0)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">[<a href="../nepomuk/Nepomuk.Query.Result.html">Nepomuk.Query.Result</a>]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#syncSparqlQuery">syncSparqlQuery</a> (QString query, {QString:<a href="../nepomuk/Nepomuk.Types.Property.html">Nepomuk.Types.Property</a>} requestPropertyMap=Nepomuk.Query.RequestPropertyMap(), bool ok=0)</td></tr>
</table>
<hr><h2>Signal Documentation</h2><a class="anchor" name="entriesRemoved"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> entriesRemoved</td>
<td>(</td>
<td class="paramtype">[QUrl]&nbsp;</td>
<td class="paramname"><em>entries</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Emitted if the search results changed when monitoring a query.
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>entries</em>&nbsp;</td><td> A list of resource URIs identifying the resources
that dropped out of the query results.
</td></tr>
</table></dl>
<p>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("entriesRemoved(const QList<QUrl>&)"), target_slot)</code></dd></dl></div></div><a class="anchor" name="error"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> error</td>
<td>(</td>
<td class="paramtype">QString&nbsp;</td>
<td class="paramname"><em>errorMessage</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Emitted when an error occurs. This typically happens in case the query
service is not running or does not respond. No further signals will be
emitted after this one.
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.6
</dd></dl>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("error(const QString&)"), target_slot)</code></dd></dl></div></div><a class="anchor" name="finishedListing"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> finishedListing</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname">)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Emitted when the initial listing has been finished, ie. if all
results have been reported via newEntries. If no further updates
are necessary the client should be closed now.
</p>
<p>
In case of an error this signal is not emitted.
</p>
<p>
\sa error()
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("finishedListing()"), target_slot)</code></dd></dl></div></div><a class="anchor" name="newEntries"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> newEntries</td>
<td>(</td>
<td class="paramtype">[<a href="../nepomuk/Nepomuk.Query.Result.html">Nepomuk.Query.Result</a>]&nbsp;</td>
<td class="paramname"><em>entries</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Emitted for new search results. This signal is emitted both
for the initial listing and for changes to the search.
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("newEntries(const QList<Nepomuk::Query::Result>&)"), target_slot)</code></dd></dl></div></div><a class="anchor" name="resultCount"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> resultCount</td>
<td>(</td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>count</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>The number of results that are reported via newEntries() before the
finishedListing() signal.
</p>
<p>
Emitted once the count of the results is available. This might
happen before the first result is emitted, in between the results, or
in rare cases it could even happen after all results have been reported.
</p>
<p>
Also be aware that no count will be provided when using sparqlQuery()
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.6
</dd></dl>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("resultCount(int)"), target_slot)</code></dd></dl></div></div><hr><h2>Method Documentation</h2><a class="anchor" name="QueryServiceClient"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">__init__</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">QObject&nbsp;</td>
<td class="paramname"><em>parent=0</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Create a new QueryServiceClient instance.
</p></div></div><a class="anchor" name="blockingDesktopQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool blockingDesktopQuery</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">QString&nbsp;</td>
<td class="paramname"><em>query</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> a desktop query string which can be parsed by QueryParser.
</td></tr>
</table></dl>
<p> \sa desktopQuery(const QString&amp;), close()
</p></div></div><a class="anchor" name="blockingQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool blockingQuery</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../nepomuk/Nepomuk.Query.Query.html">Nepomuk.Query.Query</a>&nbsp;</td>
<td class="paramname"><em>query</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Start a query using the Nepomuk query service.
</p>
<p>
Results will be reported as with query(const QString&amp;)
but a local event loop will be started to block the method
call until all results have been listed.
</p>
<p>
The client will be closed after the initial listing. Thus,
changes to results will not be reported as it is the case
with the non-blocking methods.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> the query to perform.
</td></tr>
</table></dl>
<p> <dl class="return" compact><dt><b>Returns:</b></dt><dd> <b>true</b> if the query service was found and the query
was started. <b>false</b> otherwise.
</dd></dl> </p>
<p>
\sa query(const Query&amp;), close()
</p></div></div><a class="anchor" name="blockingSparqlQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool blockingSparqlQuery</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">QString&nbsp;</td>
<td class="paramname"><em>query</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">{QString:<a href="../nepomuk/Nepomuk.Types.Property.html">Nepomuk.Types.Property</a>}&nbsp;</td>
<td class="paramname"><em>requestPropertyMap=Nepomuk.Query.RequestPropertyMap()</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> a SPARQL query which binds results to variable <b>'r'.</b>
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>requestPropertyMap</em>&nbsp;</td><td> An optional mapping of variable binding names in <b>query</b>
to their corresponding properties. For details see sparqlQuery.
</td></tr>
</table></dl>
<p> \sa sparqlQuery(const Query&amp;)
</p></div></div><a class="anchor" name="close"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> close</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Close the client, thus stop to monitor the query
for changes. Without closing the client it will continue
signalling changes to the results.
</p>
<p>
This will also make any blockingQuery return immediately.
</p></div></div><a class="anchor" name="desktopQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool desktopQuery</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">QString&nbsp;</td>
<td class="paramname"><em>query</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> a desktop query string which can be parsed by QueryParser.
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="errorMessage"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">QString errorMessage</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>The last error message which has been emitted via error() or an
empty string if there was no error.
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.6
</dd></dl>
</p></div></div><a class="anchor" name="isListingFinished"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool isListingFinished</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p><dl class="return" compact><dt><b>Returns:</b></dt><dd> <b>true</b> if all results have been listed (ie. finishedListing() has
been emitted), close() has been called, or no query was started.
</dd></dl> </p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.6
</dd></dl>
</p></div></div><a class="anchor" name="query"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool query</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../nepomuk/Nepomuk.Query.Query.html">Nepomuk.Query.Query</a>&nbsp;</td>
<td class="paramname"><em>query</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Start a query using the Nepomuk query service.
</p>
<p>
Results will be reported via newEntries. All results
have been reported once finishedListing has been emitted.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> the query to perform.
</td></tr>
</table></dl>
<p> <dl class="return" compact><dt><b>Returns:</b></dt><dd> <b>true</b> if the query service was found and the query
was started. <b>false</b> otherwise.
</dd></dl>
</p></div></div><a class="anchor" name="sparqlQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool sparqlQuery</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">QString&nbsp;</td>
<td class="paramname"><em>query</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">{QString:<a href="../nepomuk/Nepomuk.Types.Property.html">Nepomuk.Types.Property</a>}&nbsp;</td>
<td class="paramname"><em>requestPropertyMap=Nepomuk.Query.RequestPropertyMap()</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> a SPARQL query which binds results to variable <b>'r'.</b>
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>requestPropertyMap</em>&nbsp;</td><td> An optional mapping of variable binding names in <b>query</b>
to their corresponding properties. These bindings will then be reported via
Result.requestProperties(). This map will be constructed automatically when using
query(const Query&amp;).
</td></tr>
</table></dl>
<p> <b>Examples: </b>
</p>
<p>
Select a simple request property as can also be done via Query.Query:
</p>
<p>
<pre class="fragment">
 QString query = "select ?r ?mtime where { "
                 "?r a nfo:FileDataObject . "
                 "?r nie:lastModified ?mtime . "
                 "}";

 QueryServiceClient.RequestPropertyMap requestPropertyMap;
 requestPropertyMap.insert( "mtime", Vocabulary.NIE.lastModified() );

 sparqlQuery( query, requestPropertyMap );
</pre>
</p>
<p>
This will report the resources themselves and their modification time in the result's request
properties:
</p>
<p>
<pre class="fragment">
 void handleResult( const Query.Result&amp; results ) {
     QDateTime lastModified = result.requestProperty( Vocabulary.NIE.lastModified() ).toDateTime();
     [...]
</pre>
</p>
<p>
While using Query.Query restricts to request properties to diret properties of the
results using a custom SPARQL query allows to use any binding as request property.
The used property URI in the mapping does not even need to match anything in the query:
</p>
<p>
<pre class="fragment">
 QString query = "select ?r ?phone where { "
                 "?r a nco:PersonContact . "
                 "?r nco:hasPhoneNumber ?n . "
                 "?n nco:phoneNumber ?phone . "
                 "}";

 QueryServiceClient.RequestPropertyMap requestPropertyMap;
 requestPropertyMap.insert( "phone", Vocabulary.NCO.hasPhoneNumber() );
</pre>
</p>
<p>
\sa Query.requestPropertyMap()
</p></div></div><hr><h2>Static Method Documentation</h2><a class="anchor" name="serviceAvailable"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool serviceAvailable</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname">)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Check if the Nepomuk query service is running.
<dl class="return" compact><dt><b>Returns:</b></dt><dd> <b>true</b> if the Nepomuk query service is running and could
be contacted via DBus, <b>false</b> otherwise
</dd></dl>
</p></div></div><a class="anchor" name="syncDesktopQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">[<a href="../nepomuk/Nepomuk.Query.Result.html">Nepomuk.Query.Result</a>] syncDesktopQuery</td>
<td>(</td>
<td class="paramtype">QString&nbsp;</td>
<td class="paramname"><em>query</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>ok=0</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> a desktop query string which can be parsed by QueryParser.
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>ok</em>&nbsp;</td><td> a valid boolean pointer, which will be set to <b>true</b>
if the query service was found and the query was started, <b>false</b> otherwise.
If you don't want to track errors, you can pass a null pointer instead.
</td></tr>
</table></dl>
<p> \sa desktopQuery(const QString&amp;)
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.5
</dd></dl>
</p></div></div><a class="anchor" name="syncQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">[<a href="../nepomuk/Nepomuk.Query.Result.html">Nepomuk.Query.Result</a>] syncQuery</td>
<td>(</td>
<td class="paramtype"><a href="../nepomuk/Nepomuk.Query.Query.html">Nepomuk.Query.Query</a>&nbsp;</td>
<td class="paramname"><em>query</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>ok=0</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Start a query using the Nepomuk query service.
</p>
<p>
A local event loop will be started to block the method
call until all results have been listed, and results will be
returned. You can check if the query was successful through
the <b>ok</b> pointer.
</p>
<p>
If updates to the query results are required an instance of QueryServiceClient
should be created and one of the non-static query methods be used.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> the query to perform.
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>ok</em>&nbsp;</td><td> a valid boolean pointer, which will be set to <b>true</b>
if the query service was found and the query was started, <b>false</b> otherwise.
If you don't want to track errors, you can pass a null pointer instead.
</td></tr>
</table></dl>
<p> <dl class="return" compact><dt><b>Returns:</b></dt><dd> a list of <b>Result</b> for the given query.
</dd></dl> </p>
<p>
\sa query(const Query&amp;)
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.5
</dd></dl>
</p></div></div><a class="anchor" name="syncSparqlQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">[<a href="../nepomuk/Nepomuk.Query.Result.html">Nepomuk.Query.Result</a>] syncSparqlQuery</td>
<td>(</td>
<td class="paramtype">QString&nbsp;</td>
<td class="paramname"><em>query</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">{QString:<a href="../nepomuk/Nepomuk.Types.Property.html">Nepomuk.Types.Property</a>}&nbsp;</td>
<td class="paramname"><em>requestPropertyMap=Nepomuk.Query.RequestPropertyMap()</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>ok=0</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> a SPARQL query which binds results to variable <b>'r'.</b>
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>ok</em>&nbsp;</td><td> a valid boolean pointer, which will be set to <b>true</b>
if the query service was found and the query was started, <b>false</b> otherwise.
If you don't want to track errors, you can pass a null pointer instead.
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>requestPropertyMap</em>&nbsp;</td><td> An optional mapping of variable binding names in <b>query</b>
to their corresponding properties. For details see sparqlQuery.
</td></tr>
</table></dl>
<p> \sa sparqlQuery(const Query&amp;)
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.5
</dd></dl>
</p></div></div>
</div>
</div>
</div>

<div id="left">

<div class="menu_box">
<div class="nav_list">
<ul>
<li><a href="../allclasses.html">Full Index</a></li>
</ul>
</div>

<a name="cp-menu" /><div class="menutitle"><div>
  <h2 id="cp-menu-project">Modules</h2>
</div></div>
<div class="nav_list">
<ul><li><a href="../akonadi/index.html">akonadi</a></li>
<li><a href="../dnssd/index.html">dnssd</a></li>
<li><a href="../kdecore/index.html">kdecore</a></li>
<li><a href="../kdeui/index.html">kdeui</a></li>
<li><a href="../khtml/index.html">khtml</a></li>
<li><a href="../kio/index.html">kio</a></li>
<li><a href="../knewstuff/index.html">knewstuff</a></li>
<li><a href="../kparts/index.html">kparts</a></li>
<li><a href="../kutils/index.html">kutils</a></li>
<li><a href="../nepomuk/index.html">nepomuk</a></li>
<li><a href="../phonon/index.html">phonon</a></li>
<li><a href="../plasma/index.html">plasma</a></li>
<li><a href="../polkitqt/index.html">polkitqt</a></li>
<li><a href="../solid/index.html">solid</a></li>
<li><a href="../soprano/index.html">soprano</a></li>
</ul></div></div>

</div>

</div>
  <div class="clearer"/>
</div>

<div id="end_body"></div>
</div>
<div id="footer"><div id="footer_text">
This documentation is maintained by <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;simon&#64;simonzone&#46;com">Simon Edwards</a>.<br />
        KDE<sup>&#174;</sup> and <a href="../images/kde_gear_black.png">the K Desktop Environment<sup>&#174;</sup> logo</a> are registered trademarks of <a href="http://ev.kde.org/" title="Homepage of the KDE non-profit Organization">KDE e.V.</a> |
        <a href="http://www.kde.org/contact/impressum.php">Legal</a>
    </div></div>
</body>
</html>
