<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
  <title>KImageEffect</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>
<body>
<span style="font-size : 10pt;">

<table width="100%">
  <tr>
    <td width ="70%">
      <h1>Namespace KImageEffect</h1><hr>
    </td>
    <td  width="30%" valign="top" align="right">
      <table>
        <tr><td align="right"><a href="../index.html">Table of contents</a></td></tr>
        <tr><td align="right"><a href="../modules.html">Modules</a></td></tr>
        <tr><td align="right"><a href="index.html">kdefx Classes</a></td></tr>
        <tr><td align="right"><a href="../allclasses.html">All Classes</a></td></tr>
      </table>
    </td>
  </tr>
</table>
<table cellpadding="10">
  <tr>
    <td valign="top" width="35%">
      <table bgcolor="#f7f7ff" cellpadding="4">
        <tr>
          <td width="10%" align=left>Module</td>
          <td width="30%" align=left>kdefx</td>
        </tr>
        <tr>
          <td width="10%" align=left>Namespace</td>
          <td width="30%" align=left>KImageEffect</td>
        </tr>
      </table>
    </td>
    <td width="65%">
      <p>
      <p>
Functions to perform various QImage based graphical effects.
</p>

      </p>
    </td>
  </tr>
</table>
<hr>
<hr>

<h3>enums</h3><ul>
<li><b>KImageEffect.BumpmapType</b> = { Linear, Spherical, Sinuosidal }</li>

<li><b>KImageEffect.Disposition</b> = { NoImage, Centered, Tiled, CenterTiled, CenteredMaxpect, TiledMaxpect, Scaled, CenteredAutoFit }</li>

<li><b>KImageEffect.GradientType</b> = { VerticalGradient, HorizontalGradient, DiagonalGradient, CrossDiagonalGradient, PyramidGradient, RectangleGradient, PipeCrossGradient, EllipticGradient }</li>

<li><b>KImageEffect.Lighting</b> = { NorthLite, NWLite, WestLite, SWLite, SouthLite, SELite, EastLite, NELite }</li>

<li><b>KImageEffect.ModulationType</b> = { Intensity, Saturation, HueShift, Contrast }</li>

<li><b>KImageEffect.NoiseType</b> = { UniformNoise, GaussianNoise, MultiplicativeGaussianNoise, ImpulseNoise, LaplacianNoise, PoissonNoise }</li>

<li><b>KImageEffect.RGBComponent</b> = { Red, Green, Blue, Gray, All }</li>

<li><b>KImageEffect.RotateDirection</b> = { Rotate90, Rotate180, Rotate270 }</li>

</ul><a href="#extended"><i>enum details</i></a><hr>
<h3>methods</h3><ul style="list-style-type : none">
<li style="list-style-type : none"><b style="color : #000000;">addNoise</b> (src, type)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>type</td><td>KImageEffect.NoiseType</td><td align="right">KImageEffect.GaussianNoise</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Adds noise to an image.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>type</b> - The algorithm used to generate the noise.
Returns The image with noise added. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blend</b> (clr, dst, opacity)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>clr</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>dst</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>opacity</td><td>float</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blends a color into the destination image, using an opacity
value for blending one into another. Very fast direct pixel
manipulation is used.
</p>
<p>
This function uses MMX and SSE2 instructions to blend the
image on processors that support it.
</p>
<p>
</p>
<p>
<b>clr</b> - source color to be blended into the destination image.
</p>
<p>
<b>dst</b> - destination image in which the source will be blended into.
</p>
<p>
<b>opacity</b> - opacity (between 0.0 and 1.0) which determines how much
the source color will be blended into the destination image.
Returns The destination image (dst) containing the result.
<b>Author</b> Karol Szwed (gallium@kde.org)
<b>Author</b> Fredrik H&ouml;glund (fredrik@kde.org)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blend</b> (src, dst, opacity)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>dst</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>opacity</td><td>float</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend the src image into the destination image, using an opacity
value for blending one into another. Very fast direct pixel
manipulation is used.
</p>
<p>
This function uses MMX and SSE2 instructions to blend the
images on processors that support it.
</p>
<p>
</p>
<p>
<b>src</b> - source image to be blended into the destination image.
</p>
<p>
<b>dst</b> - destination image in which the source will be blended into.
</p>
<p>
<b>opacity</b> - opacity (between 0.0 and 1.0) which determines how much
the source image will be blended into the destination image.
Returns The destination image (dst) containing the result.
<b>Author</b> Karol Szwed (gallium@kde.org)
<b>Author</b> Fredrik H&ouml;glund (fredrik@kde.org)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blend</b> (image, initial_intensity, bgnd, eff, anti_dir)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>initial_intensity</td><td>float</td><td align="right"></td></tr>

              <tr><td>bgnd</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>eff</td><td>KImageEffect.GradientType</td><td align="right"></td></tr>

              <tr><td>anti_dir</td><td>bool</td><td align="right">False</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend the provided image into a background of the indicated color.
</p>
<p>
</p>
<p>
<b>initial_intensity</b> - this parameter takes values from -1 to 1:
a) if positive: how much to fade the image in its
less affected spot
b) if negative: roughly indicates how much of the image
remains unaffected
</p>
<p>
<b>bgnd</b> - indicates the color of the background to blend in
</p>
<p>
<b>eff</b> - lets you choose what kind of blending you like
</p>
<p>
<b>anti_dir</b> - blend in the opposite direction (makes no much sense
with concentric blending effects)
</p>
<p>
<b>image</b> - must be 32bpp
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blend</b> (image1, image2, gt, xf, yf)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image1</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>image2</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>gt</td><td>KImageEffect.GradientType</td><td align="right"></td></tr>

              <tr><td>xf</td><td>int</td><td align="right">100</td></tr>

              <tr><td>yf</td><td>int</td><td align="right">100</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend an image into another one, using a gradient type
for blending from one to another.
</p>
<p>
</p>
<p>
<b>image1</b> - source1 and result of blending
</p>
<p>
<b>image2</b> - source2 of blending
</p>
<p>
<b>gt</b> - gradient type for blending between source1 and source2
</p>
<p>
<b>xf</b> - x decay length for unbalanced gradient tpye
</p>
<p>
<b>yf</b> - y decay length for unbalanced gradient tpye
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blend</b> (image1, image2, blendImage, channel)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image1</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>image2</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>blendImage</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>channel</td><td>KImageEffect.RGBComponent</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend an image into another one, using a color channel of a
third image for the decision of blending from one to another.
</p>
<p>
</p>
<p>
<b>image1</b> - Source 1 and result of blending
</p>
<p>
<b>image2</b> - Source 2 of blending
</p>
<p>
<b>blendImage</b> - If the gray value of of pixel is 0, the result
for this pixel is that of image1; for a gray value
of 1, the pixel of image2 is used; for a value
in between, a corresponding blending is used.
</p>
<p>
<b>channel</b> - The RBG channel to use for the blending decision.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blend</b> (upper, lower, output)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(bool)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>upper</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>lower</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>output</td><td>QImage</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend an image into another one, using alpha in the expected way.
</p>
<p>
<b>upper</b> - the "upper" image
</p>
<p>
<b>lower</b> - the "lower" image
</p>
<p>
<b>output</b> - the target image
<b>Author</b> Rik Hemsley (rikkus) <rik@kde.org>
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blend</b> (x, y, upper, lower, output)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(bool), x (int), y (int)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>x</td><td>int</td><td align="right"></td></tr>

              <tr><td>y</td><td>int</td><td align="right"></td></tr>

              <tr><td>upper</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>lower</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>output</td><td>QImage</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend an image into another one, using alpha in the expected way and
over coordinates <b>x</b> and <b>y</b> with respect to the lower image.
The output is a QImage which is the <b>upper</b> image already blended
with the <b>lower</b> one, so its size will be (in general) the same than
<b>upper</b> instead of the same size than <b>lower</b> like the method above.
In fact, the size of <b>output</b> is like upper's one only when it can be
painted on lower, if there has to be some clipping, output's size will
be the clipped area and x and y will be set to the correct up-left corner
where the clipped rectangle begins.
</p>
<p>
<b>x</b> - x-coordinate of lower image
</p>
<p>
<b>y</b> - y-coordinate of lower image
</p>
<p>
<b>upper</b> - the "upper" image
</p>
<p>
<b>lower</b> - the "lower" image
</p>
<p>
<b>output</b> - the target image
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blendOnLower</b> (x, y, upper, lower)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(bool)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>x</td><td>int</td><td align="right"></td></tr>

              <tr><td>y</td><td>int</td><td align="right"></td></tr>

              <tr><td>upper</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>lower</td><td>QImage</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend an image into another one, using alpha in the expected way and
over coordinates <b>x</b> and <b>y</b> with respect to the lower image.
The output is painted in the own <b>lower</b> image. This is an optimization
of the blend method above provided by convenience.
</p>
<p>
<b>x</b> - x-coordinate of lower image
</p>
<p>
<b>y</b> - y-coordinate of lower image
</p>
<p>
<b>upper</b> - the "upper" image
</p>
<p>
<b>lower</b> - the "lower" image, which becomes the output image
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blendOnLower</b> (upper, upperOffset, lower, lowerRect)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>nothing</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>upper</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>upperOffset</td><td>QPoint</td><td align="right"></td></tr>

              <tr><td>lower</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>lowerRect</td><td>QRect</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend part of an image into part of another, using the alpha channel in
the expected way.
Note that the destination rectangle will be correctly clipped.
</p>
<p>
</p>
<p>
<b>upper</b> - the "upper" image
</p>
<p>
<b>upperOffset</b> - Offset for the part of the upper image to be used.
</p>
<p>
<b>lower</b> - the "lower" image
</p>
<p>
<b>lowerRect</b> - Rectangle for the part of the lower image where the
blending will occur.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blendOnLower</b> (upper, upperOffset, lower, lowerRect, opacity)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>nothing</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>upper</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>upperOffset</td><td>QPoint</td><td align="right"></td></tr>

              <tr><td>lower</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>lowerRect</td><td>QRect</td><td align="right"></td></tr>

              <tr><td>opacity</td><td>float</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend part of an image into part of another, using the opacity value
and the alpha channel in the expected way.
Note that the destination rectangle will be correctly clipped.
</p>
<p>
</p>
<p>
<b>upper</b> - the "upper" image
</p>
<p>
<b>upperOffset</b> - Offset for the part of the upper image to be used.
</p>
<p>
<b>lower</b> - the "lower" image
</p>
<p>
<b>lowerRect</b> - Rectangle for the part of the lower image where the
blending will occur.
</p>
<p>
<b>opacity</b> - Opacity (between 0.0 and 1.0) which determines how much
the source image will be blended into the destination image.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blendOnLower</b> (upper, lower, disposition, opacity)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>nothing</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>upper</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>lower</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>disposition</td><td>KImageEffect.Disposition</td><td align="right"></td></tr>

              <tr><td>opacity</td><td>float</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blend an image on top of another using a given disposition and a given
opacity. The alpha channel of the upper image is used in the expected
way. Beware the upper image may be modified.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blur</b> (src, radius, sigma)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>radius</td><td>double</td><td align="right"></td></tr>

              <tr><td>sigma</td><td>double</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Blurs an image by convolving pixel neighborhoods.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>radius</b> - The radius of the gaussian not counting the
center pixel. Use 0 and a suitable radius will be automatically used.
</p>
<p>
<b>sigma</b> - The standard deviation of the gaussian. Use 1 if you're not
sure.
Returns The blurred image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">blur</b> (src, factor)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>factor</td><td>double</td><td align="right">50.0</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
This is provided for binary compatability only! Use the above method
with a radius and sigma instead!
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">bumpmap</b> (img, map, azimuth, elevation, depth, xofs, yofs, waterlevel, ambient, compensate, invert, type, tiled)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>img</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>map</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>azimuth</td><td>double</td><td align="right"></td></tr>

              <tr><td>elevation</td><td>double</td><td align="right"></td></tr>

              <tr><td>depth</td><td>int</td><td align="right"></td></tr>

              <tr><td>xofs</td><td>int</td><td align="right"></td></tr>

              <tr><td>yofs</td><td>int</td><td align="right"></td></tr>

              <tr><td>waterlevel</td><td>int</td><td align="right"></td></tr>

              <tr><td>ambient</td><td>int</td><td align="right"></td></tr>

              <tr><td>compensate</td><td>bool</td><td align="right"></td></tr>

              <tr><td>invert</td><td>bool</td><td align="right"></td></tr>

              <tr><td>type</td><td>KImageEffect.BumpmapType</td><td align="right"></td></tr>

              <tr><td>tiled</td><td>bool</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
A bumpmapping algorithm.
</p>
<p>
</p>
<p>
<b>img</b> - the image you want bumpmap
</p>
<p>
<b>map</b> - the map used
</p>
<p>
<b>azimuth</b> - azimuth
</p>
<p>
<b>elevation</b> - elevation
</p>
<p>
<b>depth</b> - depth (not the depth of the image, but of the map)
</p>
<p>
<b>xofs</b> - X offset
</p>
<p>
<b>yofs</b> - Y offset
</p>
<p>
<b>waterlevel</b> - level that full transparency should represent
</p>
<p>
<b>ambient</b> - ambient lighting factor
</p>
<p>
<b>compensate</b> - compensate for darkening
</p>
<p>
<b>invert</b> - invert bumpmap
</p>
<p>
<b>type</b> - type of the bumpmap
</p>
<p>
<b>tiled</b> - tile the bumpmap over the image through the Y offset
</p>
<p>
Returns The destination image (dst) containing the result.
<b>Author</b> Zack Rusin <zack@kde.org>
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">channelIntensity</b> (image, percent, channel)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>percent</td><td>float</td><td align="right"></td></tr>

              <tr><td>channel</td><td>KImageEffect.RGBComponent</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Modifies the intensity of a pixmap's RGB channel component.
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to process.
</p>
<p>
<b>percent</b> - Percent value. Use a negative value to dim.
</p>
<p>
<b>channel</b> - Which channel(s) should be modified
Returns The <b>image,</b> provided for convenience.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">charcoal</b> (src, radius, sigma)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>radius</td><td>double</td><td align="right"></td></tr>

              <tr><td>sigma</td><td>double</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Produces a neat little "charcoal" effect.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>radius</b> - The radius of the gaussian not counting the
center pixel. Use 0 and a suitable radius will be automatically used.
</p>
<p>
<b>sigma</b> - The standard deviation of the gaussian. Use 1 if you're not
sure.
Returns The charcoal image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">charcoal</b> (src, factor)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>factor</td><td>double</td><td align="right">50.0</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
This is provided for binary compatability only! Use the above method
with a radius and sigma instead!
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">computeDestinationRect</b> (lowerSize, disposition, upper)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QRect)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>lowerSize</td><td>QSize</td><td align="right"></td></tr>

              <tr><td>disposition</td><td>KImageEffect.Disposition</td><td align="right"></td></tr>

              <tr><td>upper</td><td>QImage</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Compute the destination rectangle where to draw the upper image on top
of another image using the given disposition. For tiled
disposition, the rectangle should be duplicated on the whole area to
obtained the wanted effect.
</p>
<p>
</p>
<p>
<b>lowerSize</b> - The size of the destination image.
</p>
<p>
<b>disposition</b> - The wanted disposition.
</p>
<p>
<b>upper</b> - The upper image. Note that this image may be scaled to
adjust to the requested disposition.
</p>
<p>
Returns the computed rectangle. Its size may exceed lowerSize.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">contrast</b> (image, c)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>c</td><td>int</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Fast, but low quality contrast of an image. Also see contrastHSV.
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to process.
</p>
<p>
<b>c</b> - A contrast value between -255 to 255.
Returns The image(), provided for convenience.
<b>Author</b> Daniel M. Duley (mosfet)
###KDE 4: remove
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">contrastHSV</b> (img, sharpen)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>nothing</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>img</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>sharpen</td><td>bool</td><td align="right">True</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
High quality, expensive HSV contrast. You can do a faster one by just
taking a intensity threshold (ie: 128) and incrementing RGB color
channels above it and decrementing those below it, but this gives much
better results.
</p>
<p>
</p>
<p>
<b>img</b> - The QImage to process.
</p>
<p>
<b>sharpen</b> - If true sharpness is increase, (spiffed). Otherwise
it is decreased, (dulled).
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">desaturate</b> (image, desat)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>desat</td><td>float</td><td align="right">0.3</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Desaturate an image evenly.
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to process.
</p>
<p>
<b>desat</b> - A value between 0 and 1 setting the degree of desaturation
Returns Returns the image(), provided for convenience.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">despeckle</b> (src)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Minimizes speckle noise in the source image using the 8 hull
algorithm.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
Returns The despeckled image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">dither</b> (image, palette, size)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>palette</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>size</td><td>int</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Dither an image using Floyd-Steinberg dithering for low-color
situations.
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to process.
</p>
<p>
<b>palette</b> - The color palette to use
</p>
<p>
<b>size</b> - The size of the palette
Returns Returns the image(), provided for convenience.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">edge</b> (src, radius)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>radius</td><td>double</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Detects edges in an image using pixel neighborhoods and an edge
detection mask.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>radius</b> - The radius of the gaussian not counting the
center pixel. Use 0 and a suitable radius will be automatically used.
Returns The image with edges detected. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">emboss</b> (src, radius, sigma)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>radius</td><td>double</td><td align="right"></td></tr>

              <tr><td>sigma</td><td>double</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Embosses the source image. This involves highlighting the edges
and applying various other enhancements in order to get a metal
effect.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>radius</b> - The radius of the gaussian not counting the
center pixel. Use 0 and a suitable radius will be automatically used.
</p>
<p>
<b>sigma</b> - The standard deviation of the gaussian. Use 1 if you're not
sure.
Returns The embossed image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">emboss</b> (src)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Convenience method.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">equalize</b> (img)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>nothing</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>img</td><td>QImage</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Performs histogram equalisation on the reference
image.
</p>
<p>
<b>img</b> - the image that is equalised
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">fade</b> (image, val, color)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>val</td><td>float</td><td align="right"></td></tr>

              <tr><td>color</td><td>QColor</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Fade an image to a certain background color.
</p>
<p>
The number of colors will not be changed.
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to process.
</p>
<p>
<b>val</b> - The strength of the effect. 0 <= val <= 1.
</p>
<p>
<b>color</b> - The background color.
Returns Returns the image(), provided for convenience.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">flatten</b> (image, ca, cb, ncols)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>ca</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>cb</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>ncols</td><td>int</td><td align="right">0</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
This recolors a pixmap. The most dark color will become color a,
the most bright one color b, and in between.
</p>
<p>
</p>
<p>
<b>image</b> - A QImage to process.
</p>
<p>
<b>ca</b> - Color a
</p>
<p>
<b>cb</b> - Color b
</p>
<p>
<b>ncols</b> - The number of colors to dither the image to.
Pass 0 to prevent dithering.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">gradient</b> (size, ca, cb, type, ncols)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>size</td><td>QSize</td><td align="right"></td></tr>

              <tr><td>ca</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>cb</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>type</td><td>KImageEffect.GradientType</td><td align="right"></td></tr>

              <tr><td>ncols</td><td>int</td><td align="right">3</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Create a gradient from color a to color b of the specified type.
</p>
<p>
</p>
<p>
<b>size</b> - The desired size of the gradient.
</p>
<p>
<b>ca</b> - Color a
</p>
<p>
<b>cb</b> - Color b
</p>
<p>
<b>type</b> - The type of gradient.
</p>
<p>
<b>ncols</b> - The number of colors to use when not running on a
truecolor display. The gradient will be dithered to this number of
colors. Pass 0 to prevent dithering.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">hash</b> (image, lite, spacing)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>lite</td><td>KImageEffect.Lighting</td><td align="right">KImageEffect.NorthLite</td></tr>

              <tr><td>spacing</td><td>uint</td><td align="right">0</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Build a hash on any given QImage
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to process
</p>
<p>
<b>lite</b> - The hash faces the indicated lighting (cardinal poles).
</p>
<p>
<b>spacing</b> - How many unmodified pixels in between hashes.
Returns Returns the image(), provided for convenience.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">implode</b> (src, factor, background)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>factor</td><td>double</td><td align="right">30.0</td></tr>

              <tr><td>background</td><td>uint</td><td align="right">4294967295</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Implodes an image by a specified percent.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>factor</b> - The extent of the implosion.
</p>
<p>
<b>background</b> - An RGBA value to use for the background. After the
effect some pixels may be "empty". This value is used for those pixels.
Returns The imploded image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">intensity</b> (image, percent)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>percent</td><td>float</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Either brighten or dim the image by a specified percent.
For example, .50 will modify the colors by 50%.
</p>
<p>
This function uses MMX instructions to process the image
on processors that support it.
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to process.
</p>
<p>
<b>percent</b> - The percent value. Use a negative value to dim.
Returns Returns The image(), provided for convenience.
<b>Author</b> Daniel M. Duley (mosfet)
<b>Author</b> Benjamin Roe (ben@benroe.com)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">modulate</b> (image, modImage, reverse, type, factor, channel)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>modImage</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>reverse</td><td>bool</td><td align="right"></td></tr>

              <tr><td>type</td><td>KImageEffect.ModulationType</td><td align="right"></td></tr>

              <tr><td>factor</td><td>int</td><td align="right"></td></tr>

              <tr><td>channel</td><td>KImageEffect.RGBComponent</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Modulate the image with a color channel of another image.
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to modulate and result.
</p>
<p>
<b>modImage</b> - The QImage to use for modulation.
</p>
<p>
<b>reverse</b> - Invert the meaning of image/modImage; result is image!
</p>
<p>
<b>type</b> - The modulation Type to use.
</p>
<p>
<b>factor</b> - The modulation amplitude; with 0 no effect [-200;200].
</p>
<p>
<b>channel</b> - The RBG channel of image2 to use for modulation.
Returns Returns the image(), provided for convenience.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">normalize</b> (img)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>nothing</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>img</td><td>QImage</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Normalises the pixel values to span the full range of color values.
This is a contrast enhancement technique.
</p>
<p>
<b>img</b> - the image that is normalised
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">oilPaint</b> (src, radius)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>radius</td><td>int</td><td align="right">3</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
This is provided for binary compatability only! Use the above method
instead!
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">oilPaintConvolve</b> (src, radius)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>radius</td><td>double</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Produces an oil painting effect.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>radius</b> - The radius of the gaussian not counting the
center pixel. Use 0 and a suitable radius will be automatically used.
Returns The new image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">rotate</b> (src, r)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>r</td><td>KImageEffect.RotateDirection</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Rotates the image by the specified amount
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>r</b> - The rotate direction.
Returns The rotated image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">sample</b> (src, w, h)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>w</td><td>int</td><td align="right"></td></tr>

              <tr><td>h</td><td>int</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Scales an image using simple pixel sampling. This does not produce
nearly as nice a result as QImage.smoothScale(), but has the
advantage of being much faster - only a few milliseconds.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>w</b> - The new width.
</p>
<p>
<b>h</b> - The new height.
Returns The scaled image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">selectedImage</b> (img, col)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>img</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>col</td><td>QColor</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Calculate the image for a selected image, for instance a selected icon
on the desktop.
</p>
<p>
<b>img</b> - the QImage to select
</p>
<p>
<b>col</b> - the selected color, usually from QPalette.highlight().
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">shade</b> (src, color_shading, azimuth, elevation)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>color_shading</td><td>bool</td><td align="right">True</td></tr>

              <tr><td>azimuth</td><td>double</td><td align="right">30.0</td></tr>

              <tr><td>elevation</td><td>double</td><td align="right">30.0</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Shades the image using a distance light source.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>color_shading</b> - If true do color shading, otherwise do grayscale.
</p>
<p>
<b>azimuth</b> - Determines the light source and direction.
</p>
<p>
<b>elevation</b> - Determines the light source and direction.
Returns The shaded image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">sharpen</b> (src, radius, sigma)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>radius</td><td>double</td><td align="right"></td></tr>

              <tr><td>sigma</td><td>double</td><td align="right"></td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Sharpens the pixels in the image using pixel neighborhoods.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>radius</b> - The radius of the gaussian not counting the
center pixel. Use 0 and a suitable radius will be automatically used.
</p>
<p>
<b>sigma</b> - The standard deviation of the gaussian. Use 1 if you're not
sure.
Returns The sharpened image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">sharpen</b> (src, factor)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>factor</td><td>double</td><td align="right">30.0</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
This is provided for binary compatability only! Use the above method
instead!
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">solarize</b> (img, factor)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>nothing</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>img</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>factor</td><td>double</td><td align="right">50.0</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Produces a 'solarization' effect seen when exposing a photographic
film to light during the development process.
</p>
<p>
</p>
<p>
<b>img</b> - The QImage to process.
</p>
<p>
<b>factor</b> - The extent of the solarization (0-99.9)
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">spread</b> (src, amount)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>amount</td><td>uint</td><td align="right">3</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Randomly displaces pixels.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>amount</b> - The vicinity for choosing a random pixel to swap.
Returns The image with pixels displaced. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">swirl</b> (src, degrees, background)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>degrees</td><td>double</td><td align="right">50.0</td></tr>

              <tr><td>background</td><td>uint</td><td align="right">4294967295</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Swirls the image by a specified amount
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>degrees</b> - The tightness of the swirl.
</p>
<p>
<b>background</b> - An RGBA value to use for the background. After the
effect some pixels may be "empty". This value is used for those pixels.
Returns The swirled image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">threshold</b> (img, value)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>nothing</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>img</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>value</td><td>uint</td><td align="right">128</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Thresholds the reference image. You can also threshold images by using
ThresholdDither in the various QPixmap/QImage convert methods, but this
lets you specify a threshold value.
</p>
<p>
</p>
<p>
<b>img</b> - The QImage to process.
</p>
<p>
<b>value</b> - The threshold value.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">toGray</b> (image, fast)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>image</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>fast</td><td>bool</td><td align="right">False</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Convert an image to grayscale.
</p>
<p>
</p>
<p>
<b>image</b> - The QImage to process.
</p>
<p>
<b>fast</b> - Set to <b>true</b> in order to use a faster but non-photographic
quality algorithm. Appropriate for things such as toolbar icons.
Returns Returns the image(), provided for convenience.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">unbalancedGradient</b> (size, ca, cb, type, xfactor, yfactor, ncols)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>size</td><td>QSize</td><td align="right"></td></tr>

              <tr><td>ca</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>cb</td><td>QColor</td><td align="right"></td></tr>

              <tr><td>type</td><td>KImageEffect.GradientType</td><td align="right"></td></tr>

              <tr><td>xfactor</td><td>int</td><td align="right">100</td></tr>

              <tr><td>yfactor</td><td>int</td><td align="right">100</td></tr>

              <tr><td>ncols</td><td>int</td><td align="right">3</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Create an unbalanced gradient.
</p>
<p>
An unbalanced gradient is a gradient where the transition from
color a to color b is not linear, but in this case, exponential.
</p>
<p>
</p>
<p>
<b>size</b> - The desired size of the gradient.
</p>
<p>
<b>ca</b> - Color a
</p>
<p>
<b>cb</b> - Color b
</p>
<p>
<b>type</b> - The type of gradient.
</p>
<p>
<b>xfactor</b> - The x decay length. Use a value between -200 and 200.
</p>
<p>
<b>yfactor</b> - The y decay length.
</p>
<p>
<b>ncols</b> - The number of colors. See KImageEffect:gradient.
</p>

    </td>
  </tr>
</table>


</li><hr>


<li style="list-style-type : none"><b style="color : #000000;">wave</b> (src, amplitude, frequency, background)
<table width="100%">
  <tr>
    <td width="60%" valign="top">
      <table vspace="5">
        <tr>
          <td>
            returns <i>(QImage)</i>
          </td>
        </tr>
        <tr>
          <td>
          
          </td>
        </tr>
        <tr valign="bottom">
          <td>
            <table>
              <tr  bgcolor="#e7e7ff">
                <th>Argument</th><th>Type</th><th>Default</th>
              </tr>

              <tr><td>src</td><td>QImage</td><td align="right"></td></tr>

              <tr><td>amplitude</td><td>double</td><td align="right">25.0</td></tr>

              <tr><td>frequency</td><td>double</td><td align="right">150.0</td></tr>

              <tr><td>background</td><td>uint</td><td align="right">4294967295</td></tr>

            </table>
          </td>
        </tr>
      </table>
    </td>
    <td width="40%" align="left">
<p>
Modifies the pixels along a sine wave.
</p>
<p>
</p>
<p>
<b>src</b> - The QImage to process.
</p>
<p>
<b>amplitude</b> - The amplitude of the sine wave.
</p>
<p>
<b>frequency</b> - The frequency of the sine wave.
</p>
<p>
<b>background</b> - An RGBA value to use for the background. After the
effect some pixels may be "empty". This value is used for those pixels.
Returns The new image. The original is not changed.
<b>Author</b> Daniel M. Duley (mosfet)
</p>

    </td>
  </tr>
</table>


</li><hr>


</li><hr>


</span>
</body>
</html>
