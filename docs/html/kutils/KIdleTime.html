<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>KIdleTime</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="../common/doxygen.css" />
  <link rel="stylesheet" media="screen" type="text/css" title="KDE Colors" href="../common/kde.css" />
</head>
<body>
<div id="container">
<div id="header">
  <div id="header_top">
    <div>
      <div>
        <img alt ="" src="../common/top-kde.jpg"/>
        KDE 4.5 PyKDE API Reference
      </div>
    </div>
  </div>
  <div id="header_bottom">
    <div id="location">
      <ul>
        <li>KDE's Python API</li>
      </ul>
    </div>

    <div id="menu">
      <ul>
        <li><a href="../modules.html">Overview</a></li>
<li><a href="http://techbase.kde.org/Development/Languages/Python">PyKDE Home</a></li>
<li><a href="http://kde.org/family/">Sitemap</a></li>
<li><a href="http://kde.org/contact/">Contact Us</a></li>
</ul>
    </div>
  </div>
</div>

<div id="body_wrapper">
<div id="body">
<div id="right">
<div class="content">
<div id="main">
<div class="clearer">&nbsp;</div>

<h1>KIdleTime Class Reference</h1>
<code>from PyKDE4.kutils import *</code>
<p>
Inherits: <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qobject.html">QObject</a><br />


<h2>Detailed Description</h2>

<p>KIdleTime is a singleton reporting information on idle time. It is useful not
only for finding out about the current idle time of the PC, but also for getting
notified upon idle time events, such as custom timeouts, or user activity.
</p>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd> All the intervals and times in this library are in milliseconds, unless
specified otherwise
</dd></dl> </p>
<p>

<dl class="author" compact><dt><b>Author:</b></dt><dd> Dario Freddi </dd></dl>
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.4
</dd></dl>
</p>
<table border="0" cellpadding="0" cellspacing="0"><tr><td colspan="2"><br><h2>Signals</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#resumingFromIdle">resumingFromIdle</a> ()</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#timeoutReached">timeoutReached</a> (int identifier)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#timeoutReached">timeoutReached</a> (int identifier, int msec)</td></tr>
<tr><td colspan="2"><br><h2>Methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#KIdleTime">__init__</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addIdleTimeout">addIdleTimeout</a> (self, int msec)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#catchNextResumeEvent">catchNextResumeEvent</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#idleTime">idleTime</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">{int:int}&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#idleTimeouts">idleTimeouts</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#removeAllIdleTimeouts">removeAllIdleTimeouts</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#removeIdleTimeout">removeIdleTimeout</a> (self, int identifier)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#simulateUserActivity">simulateUserActivity</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#stopCatchingResumeEvent">stopCatchingResumeEvent</a> (self)</td></tr>
<tr><td colspan="2"><br><h2>Static Methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="../kutils/KIdleTime.html">KIdleTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#instance">instance</a> ()</td></tr>
</table>
<hr><h2>Signal Documentation</h2><a class="anchor" name="resumingFromIdle"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> resumingFromIdle</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname">)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Triggered, if KIdleTime is catching resume events, when the system resumes from an idle state. This means
that either simulateUserActivity was called or the user sent an input to the system.
</p>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd> catchNextResumeEvent
</dd></dl>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("resumingFromIdle()"), target_slot)</code></dd></dl></div></div><a class="anchor" name="timeoutReached"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> timeoutReached</td>
<td>(</td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>identifier</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Overload. Streams the duration as well. It is guaranteed that msec will exactly
correspond to the timeout registered with addIdleTimeout
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>msec</em>&nbsp;</td><td> the time, in milliseconds, the system has been idle for
</td></tr>
</table></dl>
<p> <dl class="see" compact><dt><b>See also:</b></dt><dd> addIdleTimeout
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> removeIdleTimeout
</dd></dl>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("timeoutReached(int)"), target_slot)</code></dd></dl></div></div><a class="anchor" name="timeoutReached"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> timeoutReached</td>
<td>(</td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>identifier</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>msec</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Overload. Streams the duration as well. It is guaranteed that msec will exactly
correspond to the timeout registered with addIdleTimeout
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>msec</em>&nbsp;</td><td> the time, in milliseconds, the system has been idle for
</td></tr>
</table></dl>
<p> <dl class="see" compact><dt><b>See also:</b></dt><dd> addIdleTimeout
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> removeIdleTimeout
</dd></dl>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("timeoutReached(int, int)"), target_slot)</code></dd></dl></div></div><hr><h2>Method Documentation</h2><a class="anchor" name="KIdleTime"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">__init__</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"></div></div><a class="anchor" name="addIdleTimeout"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">int addIdleTimeout</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>msec</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Adds a new timeout to catch. When calling this method, after the system will be idle for
msec milliseconds, the signal timeoutReached will be triggered. Please note that until you will
call removeIdleTimeout or removeAllIdleTimeouts, the signal will be triggered every
time the system will be idle for msec milliseconds. This function also returns an unique
token for the timeout just added to allow easier identification.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>msec</em>&nbsp;</td><td> the time, in milliseconds, after which the signal will be triggered
</td></tr>
</table></dl>
<p> <dl class="return" compact><dt><b>Returns:</b></dt><dd> an unique identifier for the timeout being added, that will be streamed by timeoutReached
</dd></dl> </p>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd> removeIdleTimeout
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> removeAllIdleTimeouts
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> timeoutReached
</dd></dl>
</p></div></div><a class="anchor" name="catchNextResumeEvent"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> catchNextResumeEvent</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Catches the next resume from idle event. This means that whenever user activity will be registered, or
simulateUserActivity is called, the signal resumingFromIdle will be triggered.
<p>
Please note that this method will trigger the signal just for the very first resume event after the call:
this means you explicitly have to request to track every single resume event you are interested in.
</p>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd> This behavior is due to the fact that a resume event happens whenever the user sends an input to the
system. This would lead to a massive amount of signals being delivered when the PC is being used.
Moreover, you are usually interested in catching just significant resume events, such as the ones after
a significant period of inactivity. For tracking user input, you can use the more efficient methods provided
by Qt. The purpose of this library is just monitoring the activity of the user.
</dd></dl> </p>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd> resumingFromIdle
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> simulateUserActivity
</dd></dl>
</p></div></div><a class="anchor" name="idleTime"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">int idleTime</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Retrieves the idle time of the system, in milliseconds
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> the idle time of the system
</dd></dl>
</p></div></div><a class="anchor" name="idleTimeouts"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">{int:int} idleTimeouts</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Returns the list of timeout identifiers associated with their duration, in milliseconds,
the library is currently listening to.
</p>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd> addIdleTimeout
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> removeIdleTimeout
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> timeoutReached
</dd></dl>
</p></div></div><a class="anchor" name="removeAllIdleTimeouts"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> removeAllIdleTimeouts</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Stops catching every set timeout (if any). This means that after calling this method, the signal
timeoutReached won't be called again until you will add another timeout
</p>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd> timeoutReached
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> addIdleTimeout
</dd></dl>
</p></div></div><a class="anchor" name="removeIdleTimeout"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> removeIdleTimeout</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>identifier</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Stops catching the idle timeout identified by the token identifier,
if it was registered earlier with addIdleTimeout.
Otherwise does nothing.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>identifier</em>&nbsp;</td><td> the token returned from addIdleTimeout of the timeout you want to stop listening to
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="simulateUserActivity"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> simulateUserActivity</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Attempts to simulate user activity. This implies that after calling this
method, the idle time of the system will become 0 and eventually resumingFromIdle
will be triggered
</p>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd> resumingFromIdle
</dd></dl>
</p></div></div><a class="anchor" name="stopCatchingResumeEvent"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> stopCatchingResumeEvent</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Stops listening for resume event. This function serves for canceling catchNextResumeEvent, as it
will have effect just when catchNextResumeEvent has been called and resumingFromIdle not
yet triggered
</p>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd> resumingFromIdle
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> catchNextResumeEvent
</dd></dl>
</p></div></div><hr><h2>Static Method Documentation</h2><a class="anchor" name="instance"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="../kutils/KIdleTime.html">KIdleTime</a> instance</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname">)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Returns the singleton instance. Use this method to access KIdleTime
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> the instance of KIdleTime
</dd></dl>
</p></div></div>
</div>
</div>
</div>

<div id="left">

<div class="menu_box">
<div class="nav_list">
<ul>
<li><a href="../allclasses.html">Full Index</a></li>
</ul>
</div>

<a name="cp-menu" /><div class="menutitle"><div>
  <h2 id="cp-menu-project">Modules</h2>
</div></div>
<div class="nav_list">
<ul><li><a href="../akonadi/index.html">akonadi</a></li>
<li><a href="../dnssd/index.html">dnssd</a></li>
<li><a href="../kdecore/index.html">kdecore</a></li>
<li><a href="../kdeui/index.html">kdeui</a></li>
<li><a href="../khtml/index.html">khtml</a></li>
<li><a href="../kio/index.html">kio</a></li>
<li><a href="../knewstuff/index.html">knewstuff</a></li>
<li><a href="../kparts/index.html">kparts</a></li>
<li><a href="../kutils/index.html">kutils</a></li>
<li><a href="../nepomuk/index.html">nepomuk</a></li>
<li><a href="../phonon/index.html">phonon</a></li>
<li><a href="../plasma/index.html">plasma</a></li>
<li><a href="../polkitqt/index.html">polkitqt</a></li>
<li><a href="../solid/index.html">solid</a></li>
<li><a href="../soprano/index.html">soprano</a></li>
</ul></div></div>

</div>

</div>
  <div class="clearer"/>
</div>

<div id="end_body"></div>
</div>
<div id="footer"><div id="footer_text">
This documentation is maintained by <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;simon&#64;simonzone&#46;com">Simon Edwards</a>.<br />
        KDE<sup>&#174;</sup> and <a href="../images/kde_gear_black.png">the K Desktop Environment<sup>&#174;</sup> logo</a> are registered trademarks of <a href="http://ev.kde.org/" title="Homepage of the KDE non-profit Organization">KDE e.V.</a> |
        <a href="http://www.kde.org/contact/impressum.php">Legal</a>
    </div></div>
</body>
</html>
