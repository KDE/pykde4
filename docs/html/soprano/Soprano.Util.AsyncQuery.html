<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>Soprano.Util.AsyncQuery</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="../common/doxygen.css" />
  <link rel="stylesheet" media="screen" type="text/css" title="KDE Colors" href="../common/kde.css" />
</head>
<body>
<div id="container">
<div id="header">
  <div id="header_top">
    <div>
      <div>
        <img alt ="" src="../common/top-kde.jpg"/>
        KDE 4.5 PyKDE API Reference
      </div>
    </div>
  </div>
  <div id="header_bottom">
    <div id="location">
      <ul>
        <li>KDE's Python API</li>
      </ul>
    </div>

    <div id="menu">
      <ul>
        <li><a href="../modules.html">Overview</a></li>
<li><a href="http://techbase.kde.org/Development/Languages/Python">PyKDE Home</a></li>
<li><a href="http://kde.org/family/">Sitemap</a></li>
<li><a href="http://kde.org/contact/">Contact Us</a></li>
</ul>
    </div>
  </div>
</div>

<div id="body_wrapper">
<div id="body">
<div id="right">
<div class="content">
<div id="main">
<div class="clearer">&nbsp;</div>

<h1>AsyncQuery Class Reference</h1>
<code>from PyKDE4.soprano import *</code>
<p>
Inherits: <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qobject.html">QObject</a>,<a href="../soprano/Soprano.Error.ErrorCache.html">Soprano.Error.ErrorCache</a><br />

Namespace: <a href="../soprano/Soprano.Util.html">Soprano.Util</a><br />
<h2>Detailed Description</h2>

<p>\class AsyncQuery asyncquery.h Soprano/Util/AsyncQuery
</p>
<p>
A wrapper around Soprano.Model which executes a query
in a separate thread and allows to iterate the results
asyncroneously.
</p>
<p>
In contrast to AsyncModel everything is asyncroneous, not only
the execution of the query itself, but also the iteration.
</p>
<p>
For executing a query asyncroneously simply use the static executeQuery()
method which will return a pointer to the newly created query object.
</p>
<p>
AsyncQuery objects will always delete themselves once the end of
the iterator is reached and the finished signal has been emitted.
This also means that boolean results need to be read in a slot
connected to the finished() signal.
</p>
<p>
Typical usage would be to connect to the nextReady() signal, use one of the
binding() methods or currentStatement() to get the current value, and then
call next() in it to trigger async iteration to the next element:
</p>
<p>
<pre class="fragment">
 void MyQueryHandler.slotNextReady( Soprano.Util.AsyncQuery* query ) {
     // do something with the current value
     addToSomeList( query-&gt;binding(0) );

     // trigger async iteration to the next element
     query-&gt;next();
 }
</pre>
</p>
<p>
\sa Soprano.Util.AsyncModel
</p>
<p>

<dl class="author" compact><dt><b>Author:</b></dt><dd> Sebastian Trueg &lt;trueg@kde.org&gt; </dd></dl>
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 2.4
</dd></dl>
</p>
<table border="0" cellpadding="0" cellspacing="0"><tr><td colspan="2"><br><h2>Signals</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#finished">finished</a> (<a href="../soprano/Soprano.Util.AsyncQuery.html">Soprano.Util.AsyncQuery</a> query)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#nextReady">nextReady</a> (<a href="../soprano/Soprano.Util.AsyncQuery.html">Soprano.Util.AsyncQuery</a> query)</td></tr>
<tr><td colspan="2"><br><h2>Methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#AsyncQuery">__init__</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="../soprano/Soprano.Node.html">Soprano.Node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#binding">binding</a> (self, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> name)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="../soprano/Soprano.Node.html">Soprano.Node</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#binding">binding</a> (self, int offset)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#bindingCount">bindingCount</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstringlist.html">QStringList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#bindingNames">bindingNames</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#boolValue">boolValue</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#close">close</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="../soprano/Soprano.BindingSet.html">Soprano.BindingSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#currentBindings">currentBindings</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="../soprano/Soprano.Statement.html">Soprano.Statement</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#currentStatement">currentStatement</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#isBinding">isBinding</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#isBool">isBool</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#isGraph">isGraph</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#next">next</a> (self)</td></tr>
<tr><td colspan="2"><br><h2>Static Methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="../soprano/Soprano.Util.AsyncQuery.html">Soprano.Util.AsyncQuery</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#executeQuery">executeQuery</a> (<a href="../soprano/Soprano.Model.html">Soprano.Model</a> model, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> query, <a href="../soprano/Soprano.Query.html#QueryLanguage">Soprano.Query.QueryLanguage</a> language, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> userQueryLanguage=QString())</td></tr>
</table>
<hr><h2>Signal Documentation</h2><a class="anchor" name="finished"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> finished</td>
<td>(</td>
<td class="paramtype"><a href="../soprano/Soprano.Util.AsyncQuery.html">Soprano.Util.AsyncQuery</a>&nbsp;</td>
<td class="paramname"><em>query</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Emitted once the last element has been read and the internal
iterator is finished after the last call to next() or if the result
of a boolean query is available.
</p>
<p>
Once this signals has been emitted the query will delete itself.
In a slot connected to this signal ErrorCache.lastError() can be
used to retrieve information about the success of the query.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> The query itself for convinience.
</td></tr>
</table></dl>
<p>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("finished(Soprano::Util::AsyncQuery*)"), target_slot)</code></dd></dl></div></div><a class="anchor" name="nextReady"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> nextReady</td>
<td>(</td>
<td class="paramtype"><a href="../soprano/Soprano.Util.AsyncQuery.html">Soprano.Util.AsyncQuery</a>&nbsp;</td>
<td class="paramname"><em>query</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Emitted once the next value is ready when iterating the result via
next(). Will be emitted automatically for the first element.
The last call in a connected slot should be next() to trigger
iteration to the next element.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> The query itself for convinience.
</td></tr>
</table></dl>
<p>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("nextReady(Soprano::Util::AsyncQuery*)"), target_slot)</code></dd></dl></div></div><hr><h2>Method Documentation</h2><a class="anchor" name="AsyncQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">__init__</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"></div></div><a class="anchor" name="binding"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="../soprano/Soprano.Node.html">Soprano.Node</a> binding</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td>
<td class="paramname"><em>name</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Get the current binding for a variable by index.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>offset</em>&nbsp;</td><td> The index of the requested variable.
</td></tr>
</table></dl>
<p> This method does only make sense for tuple queries.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> The binding for the requested variable or and invalid
node if offset is out of bounds, i.e. bigger or equal to bindingCount().
</dd></dl>
</p></div></div><a class="anchor" name="binding"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="../soprano/Soprano.Node.html">Soprano.Node</a> binding</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>offset</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Get the current binding for a variable by index.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>offset</em>&nbsp;</td><td> The index of the requested variable.
</td></tr>
</table></dl>
<p> This method does only make sense for tuple queries.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> The binding for the requested variable or and invalid
node if offset is out of bounds, i.e. bigger or equal to bindingCount().
</dd></dl>
</p></div></div><a class="anchor" name="bindingCount"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">int bindingCount</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>The number of bindings in this query result.
</p>
<p>
This method does only make sense for tuple queries.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> The number of bindings.
</dd></dl>
</p></div></div><a class="anchor" name="bindingNames"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstringlist.html">QStringList</a> bindingNames</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>This method does only make sense for tuple queries.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> The names of the bound variables in this query result.
</dd></dl>
</p></div></div><a class="anchor" name="boolValue"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool boolValue</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>This method does only make sense for boolean queries.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> The result of a boolean query (SPARQL ASK).
</dd></dl> </p>
<p>
\sa isBool()
</p></div></div><a class="anchor" name="close"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> close</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Closes the query. This will cancel the query if it is not finished yet.
Afterwards the query will delete itself. It has the same effect as
deleting the query object manually.
</p>
<p>
finished() will always be emitted in case the query was not finished yet.
</p></div></div><a class="anchor" name="currentBindings"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="../soprano/Soprano.BindingSet.html">Soprano.BindingSet</a> currentBindings</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Convenience method that puts all current bindings into one map.
This method does only make sense for tuple queries.
</p></div></div><a class="anchor" name="currentStatement"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="../soprano/Soprano.Statement.html">Soprano.Statement</a> currentStatement</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Retrieve the current Statement after nextReady has been emitted.
This method does only make sense for graph queries.
</p></div></div><a class="anchor" name="isBinding"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool isBinding</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Check if this is a tuple result.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> <b>true</b> if this result refers to a tuple query, i.e. currentBindings(),
binding(), bindingCount(), and bindingNames() return valid values.
</dd></dl>
</p></div></div><a class="anchor" name="isBool"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool isBool</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Check if this is a boolean result.
</p>
<p>
There is no need to call next() for boolean results. However, for internal reasons
backends need to always return <b>true</b> for boolean queries.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> <b>true</b> if this result refers to a boolean query (SPARQL ASK), i.e.
boolValue() returns a valid value.
</dd></dl>
</p></div></div><a class="anchor" name="isGraph"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool isGraph</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Check if this is a graph result.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> <b>true</b> if this result refers to a graph query, i.e. currentStatement()
returns valid values.
</dd></dl>
</p></div></div><a class="anchor" name="next"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool next</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Trigger iteration to the next element once the current has been read via one of
the binding() methods or currentStatement(). Be aware that this has not to be called
for the first element which is emitted automatically.
Once the next result has been retrieved the nextReady signal is emitted.
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> <b>true</b> if successful, <b>false</b> if the iteration reached the end.
</dd></dl>
</p></div></div><hr><h2>Static Method Documentation</h2><a class="anchor" name="executeQuery"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="../soprano/Soprano.Util.AsyncQuery.html">Soprano.Util.AsyncQuery</a> executeQuery</td>
<td>(</td>
<td class="paramtype"><a href="../soprano/Soprano.Model.html">Soprano.Model</a>&nbsp;</td>
<td class="paramname"><em>model</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td>
<td class="paramname"><em>query</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../soprano/Soprano.Query.html#QueryLanguage">Soprano.Query.QueryLanguage</a>&nbsp;</td>
<td class="paramname"><em>language</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td>
<td class="paramname"><em>userQueryLanguage=QString()</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Create a new query object.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>model</em>&nbsp;</td><td> The model to execute the query on.
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>query</em>&nbsp;</td><td> The query to evaluate.
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>language</em>&nbsp;</td><td> The %query language used to encode <b>query.</b>
</td></tr> </table></dl>
<p> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>userQueryLanguage</em>&nbsp;</td><td> If <b>language</b> equals Query.QueryLanguageUser
userQueryLanguage defines the language to use.
</td></tr>
</table></dl>
<p> \sa Model.executeQuery
</p>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd> A new AsyncQuery instance which is ready to be used or 0 if <b>model</b>
is 0. The query will delete itself once it is finished. It can also be deleted
at any point in time to cancel the query.
</dd></dl>
</p></div></div>
</div>
</div>
</div>

<div id="left">

<div class="menu_box">
<div class="nav_list">
<ul>
<li><a href="../allclasses.html">Full Index</a></li>
</ul>
</div>

<a name="cp-menu" /><div class="menutitle"><div>
  <h2 id="cp-menu-project">Modules</h2>
</div></div>
<div class="nav_list">
<ul><li><a href="../akonadi/index.html">akonadi</a></li>
<li><a href="../dnssd/index.html">dnssd</a></li>
<li><a href="../kdecore/index.html">kdecore</a></li>
<li><a href="../kdeui/index.html">kdeui</a></li>
<li><a href="../khtml/index.html">khtml</a></li>
<li><a href="../kio/index.html">kio</a></li>
<li><a href="../knewstuff/index.html">knewstuff</a></li>
<li><a href="../kparts/index.html">kparts</a></li>
<li><a href="../kutils/index.html">kutils</a></li>
<li><a href="../nepomuk/index.html">nepomuk</a></li>
<li><a href="../phonon/index.html">phonon</a></li>
<li><a href="../plasma/index.html">plasma</a></li>
<li><a href="../polkitqt/index.html">polkitqt</a></li>
<li><a href="../solid/index.html">solid</a></li>
<li><a href="../soprano/index.html">soprano</a></li>
</ul></div></div>

</div>

</div>
  <div class="clearer"/>
</div>

<div id="end_body"></div>
</div>
<div id="footer"><div id="footer_text">
This documentation is maintained by <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;simon&#64;simonzone&#46;com">Simon Edwards</a>.<br />
        KDE<sup>&#174;</sup> and <a href="../images/kde_gear_black.png">the K Desktop Environment<sup>&#174;</sup> logo</a> are registered trademarks of <a href="http://ev.kde.org/" title="Homepage of the KDE non-profit Organization">KDE e.V.</a> |
        <a href="http://www.kde.org/contact/impressum.php">Legal</a>
    </div></div>
</body>
</html>
