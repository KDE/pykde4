//
//     Copyright 2008 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2007 Jim Bublitz also apply

//                 Generated by twine

// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

%ModuleHeaderCode
#include <kcompletion.h>
%End



class KCompletion : QObject
{
%TypeHeaderCode
#include <kcompletion.h>
%End



public:
    enum CompOrder
    {
        Sorted,
        Insertion,
        Weighted
    };

                            KCompletion ();
    virtual QString         makeCompletion (const QString& string);
    QStringList             substringCompletion (const QString& string) const;
    QString                 previousMatch ();
    QString                 nextMatch ();
    virtual const QString&  lastMatch () const;
    QStringList             items () const;
    bool                    isEmpty () const;
    virtual void            setCompletionMode (KGlobalSettings::Completion mode);
    KGlobalSettings::Completion  completionMode () const;
    virtual void            setOrder (KCompletion::CompOrder order);
    KCompletion::CompOrder  order () const;
    virtual void            setIgnoreCase (bool ignoreCase);
    bool                    ignoreCase () const;
    QStringList             allMatches ();
    QStringList             allMatches (const QString& string);
//ig    KCompletionMatches      allWeightedMatches ();
//ig    KCompletionMatches      allWeightedMatches (const QString& string);
    virtual void            setSoundsEnabled (bool enable);
    bool                    soundsEnabled () const;
    bool                    hasMultipleMatches () const;
    void                    slotMakeCompletion (const QString& string);
    void                    slotPreviousMatch ();
    void                    slotNextMatch ();
    void                    insertItems (const QStringList& items);
    virtual void            setItems (const QStringList& list);
    void                    addItem (const QString& item);
    void                    addItem (const QString& item, uint weight);
    void                    removeItem (const QString& item);
    virtual void            clear ();

signals:
    void                    match (const QString& item);
    void                    matches (const QStringList& matchlist);
    void                    multipleMatches ();

protected:
    virtual void            postProcessMatch (QString* pMatch) const;
    virtual void            postProcessMatches (QStringList* pMatches) const;
//ig    virtual void            postProcessMatches (KCompletionMatches* pMatches) const;

private:
//force
                            KCompletion (const KCompletion&);
//end
public:
    ~KCompletion ();
};
// KCompletion

//ig typedef KSortableList<QString> KCompletionMatchesList;


//ig class KCompletionMatches;


class KCompletionBase
{
%TypeHeaderCode
#include <kcompletion.h>
%End



public:
    enum KeyBindingType
    {
        TextCompletion,
        PrevCompletionMatch,
        NextCompletionMatch,
        SubstringCompletion
    };

    typedef QMap<KCompletionBase::KeyBindingType,KShortcut> KeyBindingMap;

                            KCompletionBase ();
    KCompletion*            completionObject (bool hsig = 1);
    virtual void            setCompletionObject (KCompletion* compObj, bool hsig = 1);
    virtual void            setHandleSignals (bool handle);
    bool                    isCompletionObjectAutoDeleted () const;
    void                    setAutoDeleteCompletionObject (bool autoDelete);
    void                    setEnableSignals (bool enable);
    bool                    handleSignals () const;
    bool                    emitSignals () const;
    virtual void            setCompletionMode (KGlobalSettings::Completion mode);
    KGlobalSettings::Completion  completionMode () const;
    bool                    setKeyBinding (KCompletionBase::KeyBindingType item, const KShortcut& key);
    KShortcut               getKeyBinding (KCompletionBase::KeyBindingType item) const;
    void                    useGlobalKeyBindings ();
    virtual void            setCompletedText (const QString& text)=0;
    virtual void            setCompletedItems (const QStringList& items, bool autoSuggest = 1)=0;
    KCompletion*            compObj () const;

protected:
    KCompletionBase::KeyBindingMap  getKeyBindings () const;
    void                    setDelegate (KCompletionBase* delegate);
    KCompletionBase*        delegate () const;
//ig    virtual void            virtual_hook (int id, void* data);

private:
//force
                            KCompletionBase (const KCompletionBase&);
//end
public:
    ~KCompletionBase ();
};
// KCompletionBase



%MappedType QMap<KCompletionBase::KeyBindingType,KShortcut>
{
%TypeHeaderCode
#include <qmap.h>
%End

%ConvertFromTypeCode
    // Create the dictionary.
    PyObject *d = PyDict_New();

    if (!d)
        return NULL;

    // Set the dictionary elements.
    QMap<KCompletionBase::KeyBindingType, KShortcut>::const_iterator i = sipCpp->constBegin();

    while (i != sipCpp->constEnd())
    {
        KShortcut *t = new KShortcut(i.value());

#if PY_MAJOR_VERSION >= 3
        PyObject *kobj = PyLong_FromLong((int)i.key());
#else
        PyObject *kobj = PyInt_FromLong((int)i.key());
#endif
        PyObject *tobj = sipConvertFromNewInstance(t, sipClass_KShortcut, sipTransferObj);

        if (kobj == NULL || tobj == NULL || PyDict_SetItem(d, kobj, tobj) < 0)
        {
            Py_DECREF(d);

            if (kobj)
                Py_DECREF(kobj);

            if (tobj)
                Py_DECREF(tobj);
            else
                delete t;

            return NULL;
        }

        Py_DECREF(kobj);
        Py_DECREF(tobj);

        ++i;
    }

    return d;
%End

%ConvertToTypeCode
    PyObject *kobj, *tobj;
    SIP_SSIZE_T i = 0;

    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
    {
        if (!PyDict_Check(sipPy))
            return 0;

        while (PyDict_Next(sipPy, &i, &kobj, &tobj))
            if (!sipCanConvertToInstance(tobj, sipClass_KShortcut, SIP_NOT_NONE))
                return 0;

        return 1;
    }

    QMap<KCompletionBase::KeyBindingType, KShortcut> *qm = new QMap<KCompletionBase::KeyBindingType, KShortcut>;
 
    while (PyDict_Next(sipPy, &i, &kobj, &tobj))
    {
        int state;
#if PY_MAJOR_VERSION >= 3
        int k = PyLong_AsLong(kobj);
#else
        int k = PyInt_AsLong(kobj);
#endif
        KShortcut *t = reinterpret_cast<KShortcut *>(sipConvertToInstance(tobj, sipClass_KShortcut, sipTransferObj, SIP_NOT_NONE, &state, sipIsErr));
 
        if (*sipIsErr)
        {
            sipReleaseInstance(t, sipClass_KShortcut, state);

            delete qm;
            return 0;
        }

        qm->insert((KCompletionBase::KeyBindingType)k, *t);

        sipReleaseInstance(t, sipClass_KShortcut, state);
    }
 
    *sipCppPtr = qm;
 
    return sipGetState(sipTransferObj);
%End
};

