//
//     Copyright 2007 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2006 Jim Bublitz also apply


//                 Generated by preSip
//            PyKDE4 module kio  version KDE 3.92.0


// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

namespace KIO
{
typedef qlonglong fileoffset_t;
typedef qulonglong filesize_t;
QString              convertSize (KIO::filesize_t);
QString              number (KIO::filesize_t);
QString              convertSizeFromKiB (KIO::filesize_t);
uint                 calculateRemainingSeconds (KIO::filesize_t, KIO::filesize_t, KIO::filesize_t);
QString              convertSeconds (uint);
QTime                calculateRemaining (KIO::filesize_t, KIO::filesize_t, KIO::filesize_t);
QString              itemsSummaryString (uint, uint, uint, KIO::filesize_t, bool);
QString              encodeFileName (const QString&);
QString              decodeFileName (const QString&);

enum Command
{
    CMD_HOST, 
    CMD_CONNECT, 
    CMD_DISCONNECT, 
    CMD_SLAVE_STATUS, 
    CMD_SLAVE_CONNECT, 
    CMD_SLAVE_HOLD, 
    CMD_NONE, 
    CMD_TESTDIR, 
    CMD_GET, 
    CMD_PUT, 
    CMD_STAT, 
    CMD_MIMETYPE, 
    CMD_LISTDIR, 
    CMD_MKDIR, 
    CMD_RENAME, 
    CMD_COPY, 
    CMD_DEL, 
    CMD_CHMOD, 
    CMD_SPECIAL, 
    CMD_SETMODIFICATIONTIME, 
    CMD_REPARSECONFIGURATION, 
    CMD_META_DATA, 
    CMD_SYMLINK, 
    CMD_SUBURL, 
    CMD_MESSAGEBOXANSWER, 
    CMD_RESUMEANSWER, 
    CMD_CONFIG, 
    CMD_MULTI_GET, 
    CMD_SETLINKDEST, 
    CMD_OPEN, 
    CMD_CHOWN, 
    CMD_READ, 
    CMD_WRITE, 
    CMD_SEEK, 
    CMD_CLOSE
};


enum Error
{
    ERR_CANNOT_OPEN_FOR_READING, 
    ERR_CANNOT_OPEN_FOR_WRITING, 
    ERR_CANNOT_LAUNCH_PROCESS, 
    ERR_INTERNAL, 
    ERR_MALFORMED_URL, 
    ERR_UNSUPPORTED_PROTOCOL, 
    ERR_NO_SOURCE_PROTOCOL, 
    ERR_UNSUPPORTED_ACTION, 
    ERR_IS_DIRECTORY, 
    ERR_IS_FILE, 
    ERR_DOES_NOT_EXIST, 
    ERR_FILE_ALREADY_EXIST, 
    ERR_DIR_ALREADY_EXIST, 
    ERR_UNKNOWN_HOST, 
    ERR_ACCESS_DENIED, 
    ERR_WRITE_ACCESS_DENIED, 
    ERR_CANNOT_ENTER_DIRECTORY, 
    ERR_PROTOCOL_IS_NOT_A_FILESYSTEM, 
    ERR_CYCLIC_LINK, 
    ERR_USER_CANCELED, 
    ERR_CYCLIC_COPY, 
    ERR_COULD_NOT_CREATE_SOCKET, 
    ERR_COULD_NOT_CONNECT, 
    ERR_CONNECTION_BROKEN, 
    ERR_NOT_FILTER_PROTOCOL, 
    ERR_COULD_NOT_MOUNT, 
    ERR_COULD_NOT_UNMOUNT, 
    ERR_COULD_NOT_READ, 
    ERR_COULD_NOT_WRITE, 
    ERR_COULD_NOT_BIND, 
    ERR_COULD_NOT_LISTEN, 
    ERR_COULD_NOT_ACCEPT, 
    ERR_COULD_NOT_LOGIN, 
    ERR_COULD_NOT_STAT, 
    ERR_COULD_NOT_CLOSEDIR, 
    ERR_COULD_NOT_MKDIR, 
    ERR_COULD_NOT_RMDIR, 
    ERR_CANNOT_RESUME, 
    ERR_CANNOT_RENAME, 
    ERR_CANNOT_CHMOD, 
    ERR_CANNOT_DELETE, 
    ERR_SLAVE_DIED, 
    ERR_OUT_OF_MEMORY, 
    ERR_UNKNOWN_PROXY_HOST, 
    ERR_COULD_NOT_AUTHENTICATE, 
    ERR_ABORTED, 
    ERR_INTERNAL_SERVER, 
    ERR_SERVER_TIMEOUT, 
    ERR_SERVICE_NOT_AVAILABLE, 
    ERR_UNKNOWN, 
    ERR_UNKNOWN_INTERRUPT, 
    ERR_CANNOT_DELETE_ORIGINAL, 
    ERR_CANNOT_DELETE_PARTIAL, 
    ERR_CANNOT_RENAME_ORIGINAL, 
    ERR_CANNOT_RENAME_PARTIAL, 
    ERR_NEED_PASSWD, 
    ERR_CANNOT_SYMLINK, 
    ERR_NO_CONTENT, 
    ERR_DISK_FULL, 
    ERR_IDENTICAL_FILES, 
    ERR_SLAVE_DEFINED, 
    ERR_UPGRADE_REQUIRED, 
    ERR_POST_DENIED, 
    ERR_COULD_NOT_SEEK, 
    ERR_CANNOT_SETTIME, 
    ERR_CANNOT_CHOWN
};

QString              buildErrorString (int, const QString&);
//ig QString              buildHTMLErrorString (int, const QString&, const KUrl* = 0, int = -1);
QByteArray           rawErrorDetail (int, const QString&, const KUrl* = 0, int = -1);
QString              unsupportedActionErrorString (const QString&, int);

enum CacheControl
{
    CC_CacheOnly, 
    CC_Cache, 
    CC_Verify, 
    CC_Refresh, 
    CC_Reload
};

KIO::CacheControl    parseCacheControl (const QString&);
QString              getCacheControlString (KIO::CacheControl);
//ig QPixmap              pixmapForUrl (const KUrl&, mode_t = 0, KIconLoader::Group = KIconLoader::Desktop, int = 0, int = 0, QString* = 0);

KJobTrackerInterface* getJobTracker ();



//force
//ig typedef QMap<QString, QString> MetaData;
//end

};  // namespace KIO

//force
KIO::UDSEntry        testKIOUDSEntry (KIO::UDSEntry);
%MethodCode
//takes list | (KIO.UDSEntry)
//returns (KIO.UDSEntry)
    sipRes = a0;
%End

KIO::UDSEntryList    testKIOUDSEntryList (KIO::UDSEntryList);
%MethodCode
//takes list | (KIO.UDSEntryList)
//returns (KIO.UDSEntryList)
    sipRes = a0;
%End

%ModuleHeaderCode
#include <qmap.h>
%End

KIO::MetaData        testKIOMetaData (KIO::MetaData);
%MethodCode
//takes dict | (KIO.MetaData)
//returns (KIO.MetaData)


    PyObject *dict;
    if (sipParseArgs(&sipArgsParsed,sipArgs,"T", &PyDict_Type, &dict))
    {
        int isErr = 0;
        KIO::MetaData *map = (KIO::MetaData *)sipForceConvertTo_KIO_MetaData (dict, &isErr);
        if (isErr)
        {
            Py_INCREF (Py_None);
            return Py_None;
        }
        return sipConvertFrom_KIO_MetaData ((KIO::MetaData *)map, NULL);
    }
%End

//end


%MappedType KIO::MetaData
//converts a Python dict of QString, QString
{
%TypeHeaderCode
#include<qmap.h>
%End

%ConvertFromTypeCode
    // Convert to a Python dict

    if (!sipCpp)
        return PyDict_New();

    PyObject *dict;

    // Create the dictionary.

    if ((dict = PyDict_New()) == NULL)
        return NULL;

    // Get it.

    const QMap<QString,QString> cppmap = *sipCpp;
    QMap<QString,QString>::ConstIterator it;

    for (it = cppmap.begin (); it != cppmap.end (); ++it)
    {
        QString acpp = it.key ();
        QString bcpp = it.value ();
        PyObject *ainst = 0;
        PyObject *binst = 0;
        if (((ainst = sipBuildResult (NULL, "N", new QString (acpp), sipClass_QString)) == NULL)
            || ((binst = sipBuildResult (NULL, "N", new QString (bcpp), sipClass_QString)) == NULL)
            || (PyDict_SetItem (dict, ainst, binst) < 0))
        {
            Py_XDECREF (ainst);
            Py_XDECREF (binst);
            Py_DECREF (dict);
            return NULL;
        }
    }

    return dict;
%End


%ConvertToTypeCode
    // Convert a Python dictionary to a QMap on the heap.

    if (sipIsErr == NULL)
        return PyDict_Check(sipPy);


    QMap<QString,QString> *cppmap = new QMap<QString,QString>;

    PyObject *aelem, *belem;
    int pos = 0;
    QString *acpp;
    QString *bcpp;

    while (PyDict_Next(sipPy, &pos, &aelem, &belem))
    {
        int iserr = 0;

        acpp = (QString *)sipForceConvertTo_QString (aelem, &iserr);
        bcpp = (QString *)sipForceConvertTo_QString (belem, &iserr);

        if (iserr)
        {
            *sipIsErr = 1;
            delete cppmap;
            return 0;
        }

        cppmap->insert (*acpp, *bcpp);
    }

    *sipCppPtr = (KIO::MetaData *)cppmap;

    return 1;
%End
};


