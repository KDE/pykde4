//
//     Copyright 2007 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2006 Jim Bublitz also apply


//                 Generated by preSip
//            PyKDE4 module kparts  version KDE 3.92.0


// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

%ModuleHeaderCode
#include <klibloader.h>
#include <qstring.h>
%End

namespace KParts
{

class PartBase : KXMLGUIClient
{
%TypeHeaderCode
#include <part.h>
%End


public:
                         PartBase ();
    void                 setPartObject (QObject*);
    QObject*             partObject () const;

protected:
    virtual void         setComponentData (const KComponentData&);
    virtual void         setComponentData (const KComponentData&, bool);

//ig     enum PluginLoadingMode {DoNotLoadPlugins, LoadPlugins, LoadPluginsIfEnabled};

    void                 loadPlugins (QObject* /Transfer/, KXMLGUIClient*, const KComponentData&);
//ig     void                 setPluginLoadingMode (KParts::PartBase::PluginLoadingMode);
    void                 setPluginInterfaceVersion (int);

protected:
//ig                          PartBase (PartBasePrivate&);

private:
                         PartBase (const KParts::PartBase&) [()];

};  // class PartBase


class Part : QObject, KParts::PartBase
{
%TypeHeaderCode
#include <part.h>
%End


public:
                         Part (QObject* /TransferThis/ = 0);
    virtual void         embed (QWidget*);
    virtual QWidget*     widget ();
    virtual void         setManager (KParts::PartManager*);
    KParts::PartManager* manager ();
    void                 setAutoDeleteWidget (bool);
    void                 setAutoDeletePart (bool);
    virtual KParts::Part* hitTest (QWidget*, const QPoint&);
    virtual void         setSelectable (bool);
    bool                 isSelectable () const;
    KIconLoader*         iconLoader ();

signals:
    void                 setWindowCaption (const QString&);
    void                 setStatusBarText (const QString&);

protected:
    virtual void         setWidget (QWidget*);
    virtual void         customEvent (QEvent*);
    virtual void         partActivateEvent (KParts::PartActivateEvent*);
    virtual void         partSelectEvent (KParts::PartSelectEvent*);
    virtual void         guiActivateEvent (KParts::GUIActivateEvent*);
    QWidget*             hostContainer (const QString&);

protected slots:
    void                 slotWidgetDestroyed ();

protected:
//ig                          Part (PartPrivate&, QObject* /TransferThis/);

private:
                         Part (const KParts::Part&) [()];

};  // class Part


class OpenUrlArguments
{
%TypeHeaderCode
#include <part.h>
%End


public:
                         OpenUrlArguments ();
                         OpenUrlArguments (const KParts::OpenUrlArguments&);
    bool                 reload () const;
    void                 setReload (bool);
    int                  xOffset () const;
    void                 setXOffset (int);
    int                  yOffset () const;
    void                 setYOffset (int);
    QString              mimeType () const;
    void                 setMimeType (const QString&);
    QMap<QString, QString>& metaData ();

};  // class OpenUrlArguments

//doc
// Even though this is an abstract class, you can use
// createReadOnlyPart (see below) without creating
// a concrete instance of this class.
//end

class ReadOnlyPart : KParts::Part
{
%TypeHeaderCode
#include <part.h>
%End


public:
                         ReadOnlyPart (QObject* /TransferThis/ = 0);
    void                 setProgressInfoEnabled (bool);
    bool                 isProgressInfoEnabled () const;
    void                 showProgressInfo (bool);

public slots:
    virtual bool         openUrl (const KUrl&);

public:
    KUrl                 url () const;
    virtual bool         closeUrl ();
    KParts::BrowserExtension* browserExtension () const;
    void                 setArguments (const KParts::OpenUrlArguments&);
    KParts::OpenUrlArguments arguments () const;

public:
    bool                 openStream (const QString&, const KUrl&);
    bool                 writeStream (const QByteArray&);
    bool                 closeStream ();

signals:
    void                 started (KIO::Job*);
    void                 completed ();
    void                 completed (bool);
    void                 canceled (const QString&);

protected:
    virtual bool         openFile ()  = 0;
    void                 abortLoad ();
    virtual void         guiActivateEvent (KParts::GUIActivateEvent*);
    bool                 isLocalFileTemporary () const;
    void                 setLocalFileTemporary (bool);
    void                 setUrl (const KUrl&);
    QString              localFilePath () const;
    void                 setLocalFilePath (const QString&);

protected:
//ig                          ReadOnlyPart (ReadOnlyPartPrivate&, QObject* /TransferThis/);

private:
                         ReadOnlyPart (const KParts::ReadOnlyPart&) [()];

};  // class ReadOnlyPart

//doc
// Even though this is an abstract class, you can use
// createReadWritePart (see below) without creating a concrete instance
// of this class.
//end

class ReadWritePart : KParts::ReadOnlyPart
{
%TypeHeaderCode
#include <part.h>
%End


public:
                         ReadWritePart (QObject* /TransferThis/ = 0);
    bool                 isReadWrite () const;
    virtual void         setReadWrite (bool = 1);
    bool                 isModified () const;
    virtual bool         queryClose ();
    virtual bool         closeUrl ();
    virtual bool         closeUrl (bool);
    virtual bool         saveAs (const KUrl&);
    virtual void         setModified (bool);

signals:
//ig     void                 sigQueryClose (bool*, bool*);

public slots:
    virtual void         setModified ();
    virtual bool         save ();
    bool                 waitSaveComplete ();

protected:
    virtual bool         saveFile ()  = 0;
    virtual bool         saveToUrl ();

private:
                         ReadWritePart (const KParts::ReadWritePart&) [()];

};  // class ReadWritePart

};  // namespace KParts

//force
//doc
// <para>
// This is a PyKDE-only function that handles the machinery necessary
// to create a KParts::ReadOnlyPart. It executes the following C++ code:
// </para>
// <pre class="PROGRAMLISTING">
// KParts::ReadOnlyPart *createReadOnlyPart (const QString&amp; lib,
//                                           QObject *parent,
//                                           const QString&amp; name,
//                                             const QStringList &amp;args)
// {
//    KLibFactory *factory = KLibLoader::self ()-&gt;factory ((const char *)lib);
//
//    if (factory)
//            return static_cast&lt;KParts::ReadOnlyPart*&gt; (factory-&gt;create (parent,
//                                               (const char *)name, args));
//        else
//                return NULL;
// </pre>
// <para>
// Notice that it takes care of creating the KLibFactory for you, and
// returns the part cast to type KParts::ReadOnlyPart.  The actual
// part has a different class (derived from KParts::ReadOnlyPart),
// and calls to openURL or openFile will use the part's overloaded
// methods. Currently it isn't possible to call KParts::ReadOnlyPart::openURL
// if it has been overloaded.
// </para>
// <para>
// Usage: KParts.createReadOnlyPart (lib, parent, name, args)
// </para>
//end
KParts::ReadOnlyPart* createReadOnlyPart (const QString&, QObject* = 0, const QString& = QString::null , const QStringList& = QStringList ());
//doc
// <para>
// This is a PyKDE-only function that handles the machinery necessary
// to create a KParts::ReadWritePart. It executes the following C++ code:
// </para>
// <pre class="PROGRAMLISTING">
// KParts::ReadWritePart *createReadWritePart (const QString&amp; lib,
//                                             QObject *parent,
//                                             const QString&amp; name, 
//                                             const QStringList &amp;args)
// {
//     KLibFactory *factory = KLibLoader::self ()-&gt;factory ((const char *)lib);
//
//     if (factory)
//             return static_cast&lt;KParts::ReadWritePart*&gt; (factory-&gt;create (parent,
//                                                (const char *)name, args));
//         else
//                 return NULL;
// </pre>
// <para>
// Notice that it takes care of creating the KLibFactory for you, and
// returns the part cast to type KParts::ReadWritePart.  The actual
// part has a different class (derived from KParts::ReadWritePart),
// and calls to openURL or openFile will use the part's overloaded
// methods. Currently it isn't possible to call KParts::ReadWritePart::openURL
// if it has been overloaded.
// </para>
// <para>
// Usage: KParts.createReadWritePart (lib, parent, name, args)
// </para>
//end
KParts::ReadWritePart* createReadWritePart (const QString&, QObject* = 0, const QString& = QString::null , const QStringList& = QStringList ());
//end


%ModuleCode
KParts::ReadOnlyPart *createReadOnlyPart (const QString& lib, QObject *parent, const QString& name, const QStringList &args)
{
        KParts::ReadOnlyPart *res = NULL;

        KLibFactory *factory = KLibLoader::self ()->factory ((const char *)lib.toAscii ().data ());

        if (factory)
                res = static_cast<KParts::ReadOnlyPart*> (factory->create (parent, (const char *) name.toAscii ().data (), args));

        return res;
}

KParts::ReadWritePart *createReadWritePart (const QString& lib, QObject *parent, const QString& name, const QStringList &args)
{
        KParts::ReadWritePart *res = NULL;

        KLibFactory *factory = KLibLoader::self ()->factory ((const char *) lib.toAscii ().data ());

        if (factory)
                res = static_cast<KParts::ReadWritePart*> (factory->create (parent, (const char *) name.toAscii ().data (), args));

        return res;
}
%End
