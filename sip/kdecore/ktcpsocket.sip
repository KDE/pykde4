//
//     Copyright 2009 Simon Edwards <simon@simonzone.com>

//                 Generated by twine

// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


class KSslKey
{
%TypeHeaderCode
#include <ktcpsocket.h>
%End


public:
    enum Algorithm
    {
        Rsa,
        Dsa,
        Dh
    };


    enum KeySecrecy
    {
        PublicKey,
        PrivateKey
    };

                            KSslKey ();
                            KSslKey (const KSslKey& other);
                            KSslKey (const QSslKey& sslKey);
    KSslKey::Algorithm      algorithm () const;
    bool                    isExportable () const;
    KSslKey::KeySecrecy     secrecy () const;
    QByteArray              toDer () const;
    ~KSslKey ();
};
// KSslKey


class KSslCipher
{
%TypeHeaderCode
#include <ktcpsocket.h>
%End

public:
                            KSslCipher ();
                            KSslCipher (const KSslCipher& other);
                            KSslCipher (const QSslCipher&);
    bool                    isNull () const;
    QString                 authenticationMethod () const;
    QString                 encryptionMethod () const;
    QString                 keyExchangeMethod () const;
    QString                 digestMethod () const;
    QString                 name () const;
    int                     supportedBits () const;
    int                     usedBits () const;
    static QList<KSslCipher>  supportedCiphers ();
    ~KSslCipher ();
};
// KSslCipher


class KSslError
{
%TypeHeaderCode
#include <ktcpsocket.h>
%End


public:
    enum Error
    {
        NoError,
        UnknownError,
        InvalidCertificateAuthorityCertificate,
        InvalidCertificate,
        CertificateSignatureFailed,
        SelfSignedCertificate,
        ExpiredCertificate,
        RevokedCertificate,
        InvalidCertificatePurpose,
        RejectedCertificate,
        UntrustedCertificate,
        NoPeerCertificate,
        HostNameMismatch,
        PathLengthExceeded
    };

                            KSslError (KSslError::Error error = KSslError::NoError, const QSslCertificate& cert = QSslCertificate());
                            KSslError (const QSslError& error);
                            KSslError (const KSslError& other);
    KSslError::Error        error () const;
    QString                 errorString () const;
    QSslCertificate         certificate () const;
    ~KSslError ();
};
// KSslError


class KTcpSocket : QIODevice
{
%TypeHeaderCode
#include <ktcpsocket.h>
%End


public:
    enum State
    {
        UnconnectedState,
        HostLookupState,
        ConnectingState,
        ConnectedState,
        BoundState,
        ListeningState,
        ClosingState
    };


    enum SslVersion
    {
        UnknownSslVersion,
        SslV2,
        SslV3,
        TlsV1,
        SslV3_1,
        TlsV1SslV3,
        SecureProtocols,
        AnySslVersion
    };

    typedef QFlags<KTcpSocket::SslVersion> SslVersions;


    enum Error
    {
        UnknownError,
        ConnectionRefusedError,
        RemoteHostClosedError,
        HostNotFoundError,
        SocketAccessError,
        SocketResourceError,
        SocketTimeoutError,
        NetworkError,
        UnsupportedSocketOperationError
    };


    enum EncryptionMode
    {
        UnencryptedMode,
        SslClientMode,
        SslServerMode
    };


    enum ProxyPolicy
    {
        AutoProxy,
        ManualProxy
    };

                            KTcpSocket (QObject* parent /TransferThis/ = 0);
    virtual bool            atEnd () const;
    virtual qint64          bytesAvailable () const;
    virtual qint64          bytesToWrite () const;
    virtual bool            canReadLine () const;
    virtual void            close ();
    virtual bool            isSequential () const;
    virtual bool            open (QIODevice::OpenMode open);
    virtual bool            waitForBytesWritten (int msecs);
    virtual bool            waitForReadyRead (int msecs = 30000);

protected:
//ig    virtual qint64          readData (char* data, qint64 maxSize);
//ig    virtual qint64          writeData (const char* data, qint64 maxSize);

public:
    void                    abort ();
    void                    connectToHost (const QString& hostName, quint16 port, KTcpSocket::ProxyPolicy policy = KTcpSocket::AutoProxy);
    void                    connectToHost (const QHostAddress& hostAddress, quint16 port, KTcpSocket::ProxyPolicy policy = KTcpSocket::AutoProxy);
    void                    connectToHost (const KUrl& url, KTcpSocket::ProxyPolicy policy = KTcpSocket::AutoProxy);
    void                    disconnectFromHost ();
    KTcpSocket::Error       error () const;
    QList<KSslError>        sslErrors () const;
    bool                    flush ();
    bool                    isValid () const;
    QHostAddress            localAddress () const;
    QHostAddress            peerAddress () const;
    QString                 peerName () const;
    quint16                 peerPort () const;
    QNetworkProxy           proxy () const;
    qint64                  readBufferSize () const;
    void                    setProxy (const QNetworkProxy& proxy);
    void                    setReadBufferSize (qint64 size);
    KTcpSocket::State       state () const;
    bool                    waitForConnected (int msecs = 30000);
    bool                    waitForDisconnected (int msecs = 30000);
    void                    addCaCertificate (const QSslCertificate& certificate);
    void                    addCaCertificates (const QList<QSslCertificate>& certificates);
    QList<QSslCertificate>  caCertificates () const;
    QList<KSslCipher>       ciphers () const;
    void                    connectToHostEncrypted (const QString& hostName, quint16 port, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    QSslCertificate         localCertificate () const;
    QList<QSslCertificate>  peerCertificateChain () const;
    KSslKey                 privateKey () const;
    KSslCipher              sessionCipher () const;
    void                    setCaCertificates (const QList<QSslCertificate>& certificates);
    void                    setCiphers (const QList<KSslCipher>& ciphers);
    void                    setLocalCertificate (const QSslCertificate& certificate);
    void                    setLocalCertificate (const QString& fileName, QSsl::EncodingFormat format = QSsl::Pem);
    void                    setPrivateKey (const KSslKey& key);
    void                    setPrivateKey (const QString& fileName, KSslKey::Algorithm algorithm = KSslKey::Rsa, QSsl::EncodingFormat format = QSsl::Pem, const QByteArray& passPhrase = QByteArray());
    void                    setAdvertisedSslVersion (KTcpSocket::SslVersion version);
    KTcpSocket::SslVersion  advertisedSslVersion () const;
    KTcpSocket::SslVersion  negotiatedSslVersion () const;
    QString                 negotiatedSslVersionName () const;
    bool                    waitForEncrypted (int msecs = 30000);
    KTcpSocket::EncryptionMode  encryptionMode () const;

signals:
    void                    connected ();
    void                    disconnected ();
    void                    error (KTcpSocket::Error);
    void                    hostFound ();
    void                    proxyAuthenticationRequired (const QNetworkProxy& proxy, QAuthenticator* authenticator);
    void                    stateChanged (KTcpSocket::State);
    void                    encrypted ();
    void                    encryptionModeChanged (KTcpSocket::EncryptionMode);
    void                    sslErrors (const QList<KSslError>& errors);

public:
    void                    ignoreSslErrors ();
    void                    startClientEncryption ();
    ~KTcpSocket ();
    QVariant                socketOption (QAbstractSocket::SocketOption options) const;
    void                    setSocketOption (QAbstractSocket::SocketOption options, const QVariant& value);
    void                    setVerificationPeerName (const QString& hostName);
signals:
    void                    encryptedBytesWritten (qint64 written);
};
// KTcpSocket


class KSslErrorUiData
{
%TypeHeaderCode
#include <ktcpsocket.h>
%End

public:
                            KSslErrorUiData ();
                            KSslErrorUiData (const KTcpSocket* socket);
                            KSslErrorUiData (const KSslErrorUiData& other);
    ~KSslErrorUiData ();
                            KSslErrorUiData (const QSslSocket* socket);
};
// KSslErrorUiData


