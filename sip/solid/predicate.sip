//
//     Copyright 2008 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2007 Jim Bublitz also apply

//                 Generated by twine

// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

namespace Solid
{

class Predicate
{
%TypeHeaderCode
#include <predicate.h>
%End



public:
    enum ComparisonOperator
    {
        Equals,
        Mask
    };

                            Predicate ();
                            Predicate (const Solid::Predicate& other);
//ig                            Predicate (const Solid::DeviceInterface::Type& ifaceType, const QString& property, const QVariant& value, Solid::Predicate::ComparisonOperator compOperator = Solid::Predicate::Equals);
                            Predicate (const QString& ifaceName, const QString& property, const QVariant& value, Solid::Predicate::ComparisonOperator compOperator = Solid::Predicate::Equals);
//ig    explicit                Predicate (const Solid::DeviceInterface::Type& ifaceType);
//force
    explicit                Predicate (const Solid::DeviceInterface::Type ifaceType) [(const Solid::DeviceInterface::Type&)];
%MethodCode
Py_BEGIN_ALLOW_THREADS
    sipCpp = new Solid::Predicate (a0);
    Py_END_ALLOW_THREADS
%End

//end
    explicit                Predicate (const QString& ifaceName);
    Solid::Predicate        operator & (const Solid::Predicate& other);

    Solid::Predicate&       operator &= (const Solid::Predicate& other);

    Solid::Predicate        operator | (const Solid::Predicate& other);

    Solid::Predicate&       operator |= (const Solid::Predicate& other);

    bool                    isValid () const;
    bool                    matches (const Solid::Device& device) const;
    QSet<Solid::DeviceInterface::Type>  usedTypes () const;
    QString                 toString () const;
    static Solid::Predicate  fromString (const QString& predicate);
    ~Predicate ();
    enum Type
    {
        PropertyCheck,
        Conjunction,
        Disjunction,
        InterfaceCheck
    };
    Solid::Predicate::Type  type () const;
    Solid::DeviceInterface::Type  interfaceType () const;
    QString                 propertyName () const;
    QVariant                matchingValue () const;
    Solid::Predicate::ComparisonOperator  comparisonOperator () const;
    Solid::Predicate        firstOperand () const;
    Solid::Predicate        secondOperand () const;
};
// Predicate

};
// Solid



%MappedType QSet<Solid::DeviceInterface::Type>
{
%TypeHeaderCode
#include <qset.h>
#include <powermanagement.h>
%End

%ConvertFromTypeCode
    // Create the list.
    PyObject *l;

    if ((l = PyList_New(sipCpp->size())) == NULL)
        return NULL;

    // Set the list elements.
    QSet<Solid::DeviceInterface::Type> set = *sipCpp;
    int i = 0;
    foreach (Solid::DeviceInterface::Type value, set)
    {
#if PY_MAJOR_VERSION >= 3
        PyObject *obj = PyLong_FromLong ((long) value);
#else
        PyObject *obj = PyInt_FromLong ((long) value);
#endif
        if (obj == NULL || PyList_SET_ITEM (l, i, obj) < 0)
        {
            Py_DECREF(l);

            if (obj)
                Py_DECREF(obj);

            return NULL;
        }

        Py_DECREF(obj);
        i++;
    }
   
    return l;
%End

%ConvertToTypeCode
    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
    {
        if (!PyList_Check(sipPy))
            return 0;
    }

    // Check the type if that is all that is required.
    if (sipIsErr == NULL)
    {
        if (!PyList_Check(sipPy))
            return 0;
    }

    QSet<Solid::DeviceInterface::Type> *qs = new QSet<Solid::DeviceInterface::Type>;
 
    for (int i = 0; i < PyList_GET_SIZE(sipPy); ++i)
    {
#if PY_MAJOR_VERSION >= 3
        Solid::DeviceInterface::Type t = (Solid::DeviceInterface::Type)PyLong_AsLong (PyList_GET_ITEM (sipPy, i));
#else
        Solid::DeviceInterface::Type t = (Solid::DeviceInterface::Type)PyInt_AS_LONG (PyList_GET_ITEM (sipPy, i));
#endif
*qs << t;

    }
 
    *sipCppPtr = qs;
 
    return sipGetState(sipTransferObj);
%End
};

