<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
  <title>Akonadi.ResourceBase</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <link rel="stylesheet" type="text/css" href="../common/doxygen.css" />
  <link rel="stylesheet" media="screen" type="text/css" title="KDE Colors" href="../common/kde.css" />
</head>
<body>
<div id="container">
<div id="header">
  <div id="header_top">
    <div>
      <div>
        <img alt ="" src="../common/top-kde.jpg"/>
        KDE 4.4 PyKDE API Reference
      </div>
    </div>
  </div>
  <div id="header_bottom">
    <div id="location">
      <ul>
        <li>KDE's Python API</li>
      </ul>
    </div>

    <div id="menu">
      <ul>
        <li><a href="../modules.html">Overview</a></li>
<li><a href="http://techbase.kde.org/Development/Languages/Python">PyKDE Home</a></li>
<li><a href="http://kde.org/family/">Sitemap</a></li>
<li><a href="http://kde.org/contact/">Contact Us</a></li>
</ul>
    </div>
  </div>
</div>

<div id="body_wrapper">
<div id="body">
<div id="right">
<div class="content">
<div id="main">
<div class="clearer">&nbsp;</div>

<h1>ResourceBase Class Reference</h1>
<code>from PyKDE4.akonadi import *</code>
<p>
Inherits: Akonadi.AgentBase &#x2192; <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qobject.html">QObject</a><br />

Namespace: Akonadi.ResourceBase<br />
<h2>Detailed Description</h2>

<p>The base class for all Akonadi resources.
</p>
<p>
This class should be used as a base class by all resource agents,
because it encapsulates large parts of the protocol between
resource agent, agent manager and the Akonadi storage.
</p>
<p>
It provides many convenience methods to make implementing a
new Akonadi resource agent as simple as possible.
</p>
<p>
&lt;h4&gt;How to write a resource&lt;/h4&gt;
</p>
<p>
The following provides an overview of what you need to do to implement
your own Akonadi resource. In the following, the term 'backend' refers
to the entity the resource connects with Akonadi, be it a single file
or a remote server.
</p>
<p>
To do: Complete this (online/offline state management)
</p>
<p>
&lt;h5&gt;Basic %Resource Framework&lt;/h5&gt;
</p>
<p>
The following is needed to create a new resource:
- A new class deriving from Akonadi.ResourceBase, implementing at least all
pure-virtual methods, see below for further details.
- call init() in your main() function.
- a .desktop file similar to the following example
<pre class="fragment">
 [Desktop Entry]
 Encoding=UTF-8
 Name=My Akonadi Resource
 Type=AkonadiResource
 Exec=akonadi_my_resource
 Icon=my-icon

 X-Akonadi-MimeTypes=&lt;supported-mimetypes&gt;
 X-Akonadi-Capabilities=Resource
 X-Akonadi-Identifier=akonadi_my_resource
</pre>
</p>
<p>
&lt;h5&gt;Handling PIM Items&lt;/h5&gt;
</p>
<p>
To follow item changes in the backend, the following steps are necessary:
- Implement retrieveItems() to synchronize all items in the given
collection. If the backend supports incremental retrieval,
implementing support for that is recommended to improve performance.
- Convert the items provided by the backend to Akonadi items.
This typically happens either in retrieveItems() if you retrieved
the collection synchronously (not recommended for network backends) or
in the result slot of the asynchronous retrieval job.
Converting means to create Akonadi.Item objects for every retrieved
item. It's very important that every object has its remote identifier set.
- Call itemsRetrieved() or itemsRetrievedIncremental() respectively
with the item objects created above. The Akonadi storage will then be
updated automatically. Note that it is usually not necessary to manipulate
any item in the Akonadi storage manually.
</p>
<p>
To fetch item data on demand, the method retrieveItem() needs to be
reimplemented. Fetch the requested data there and call itemRetrieved()
with the result item.
</p>
<p>
To write local changes back to the backend, you need to re-implement
the following three methods:
- itemAdded()
- itemChanged()
- itemRemoved()
Note that these three functions don't get the full payload of the items by default,
you need to change the item fetch scope of the change recorder to fetch the full
payload. This can be expensive with big payloads, though.<br>
Once you have handled changes in these methods call changeCommitted().
These methods are called whenever a local item related to this resource is
added, modified or deleted. They are only called if the resource is online, otherwise
all changes are recorded and replayed as soon the resource is online again.
</p>
<p>
&lt;h5&gt;Handling Collections&lt;/h5&gt;
</p>
<p>
To follow collection changes in the backend, the following steps are necessary:
- Implement retrieveCollections() to retrieve collections from the backend.
If the backend supports incremental collections updates, implementing
support for that is recommended to improve performance.
- Convert the collections of the backend to Akonadi collections.
This typically happens either in retrieveCollections() if you retrieved
the collection synchronously (not recommended for network backends) or
in the result slot of the asynchronous retrieval job.
Converting means to create Akonadi.Collection objects for every retrieved
collection. It's very important that every object has its remote identifier
and its parent remote identifier set.
- Call collectionsRetrieved() or collectionsRetrievedIncremental() respectively
with the collection objects created above. The Akonadi storage will then be
updated automatically. Note that it is usually not necessary to manipulate
any collection in the Akonadi storage manually.
</p>
<p>
To write local collection changes back to the backend, you need to re-implement
the following three methods:
- collectionAdded()
- collectionChanged()
- collectionRemoved()
Once you have handled changes in these methods call changeCommitted().
These methods are called whenever a local collection related to this resource is
added, modified or deleted. They are only called if the resource is online, otherwise
all changes are recorded and replayed as soon the resource is online again.
</p>
<p>
To do: Convenience base class for collection-less resources
</p>
<table border="0" cellpadding="0" cellspacing="0"><tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="#SchedulePriority">SchedulePriority</a>&nbsp;</td><td class="memItemRight" valign="bottom">{&nbsp;Prepend, AfterChangeReplay, Append&nbsp;}</td></tr>
<tr><td colspan="2"><br><h2>Signals</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#nameChanged">nameChanged</a> (, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> name)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#synchronized">synchronized</a> ()</td></tr>
<tr><td colspan="2"><br><h2>Methods</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ResourceBase">__init__</a> (self, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> id)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#cancelTask">cancelTask</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#cancelTask">cancelTask</a> (self, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> error)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#changeCommitted">changeCommitted</a> (self, <a href="../akonadi/Akonadi.Item.html">Akonadi.Item</a> item)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#changeCommitted">changeCommitted</a> (self, <a href="../akonadi/Akonadi.Collection.html">Akonadi.Collection</a> collection)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#clearCache">clearCache</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#collectionsRetrievalDone">collectionsRetrievalDone</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#collectionsRetrieved">collectionsRetrieved</a> (self, <a href="../akonadi/Akonadi.Collection.List.html">Akonadi.Collection.List</a> collections)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#collectionsRetrievedIncremental">collectionsRetrievedIncremental</a> (self, <a href="../akonadi/Akonadi.Collection.List.html">Akonadi.Collection.List</a> changedCollections, <a href="../akonadi/Akonadi.Collection.List.html">Akonadi.Collection.List</a> removedCollections)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="../akonadi/Akonadi.Collection.html">Akonadi.Collection</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#currentCollection">currentCollection</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="../akonadi/Akonadi.Item.html">Akonadi.Item</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#currentItem">currentItem</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#deferTask">deferTask</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#doSetOnline">doSetOnline</a> (self, bool online)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#itemRetrieved">itemRetrieved</a> (self, <a href="../akonadi/Akonadi.Item.html">Akonadi.Item</a> item)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#itemsRetrievalDone">itemsRetrievalDone</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#itemsRetrieved">itemsRetrieved</a> (self, <a href="../akonadi/Akonadi.Item.List.html">Akonadi.Item.List</a> items)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#itemsRetrievedIncremental">itemsRetrievedIncremental</a> (self, <a href="../akonadi/Akonadi.Item.List.html">Akonadi.Item.List</a> changedItems, <a href="../akonadi/Akonadi.Item.List.html">Akonadi.Item.List</a> removedItems)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#name">name</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#nameChanged">nameChanged</a> (self, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> name)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#retrieveCollections">retrieveCollections</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#retrieveItem">retrieveItem</a> (self, <a href="../akonadi/Akonadi.Item.html">Akonadi.Item</a> item, QSet<QByteArray> parts)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#retrieveItems">retrieveItems</a> (self, <a href="../akonadi/Akonadi.Collection.html">Akonadi.Collection</a> collection)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#scheduleCustomTask">scheduleCustomTask</a> (self, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qobject.html">QObject</a> receiver, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> method, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qvariant.html">QVariant</a> argument, <a href="../akonadi/Akonadi.ResourceBase.html#SchedulePriority">Akonadi.ResourceBase.SchedulePriority</a> priority)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#setCollectionStreamingEnabled">setCollectionStreamingEnabled</a> (self, bool enable)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#setHierarchicalRemoteIdentifiersEnabled">setHierarchicalRemoteIdentifiersEnabled</a> (self, bool enable)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#setItemStreamingEnabled">setItemStreamingEnabled</a> (self, bool enable)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#setName">setName</a> (self, <a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> name)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#setTotalItems">setTotalItems</a> (self, int amount)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#synchronize">synchronize</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#synchronizeCollection">synchronizeCollection</a> (self, long id)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#synchronizeCollectionTree">synchronizeCollectionTree</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#synchronized">synchronized</a> (self)</td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="#taskDone">taskDone</a> (self)</td></tr>
</table>
<hr><h2>Method Documentation</h2><a class="anchor" name="ResourceBase"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">__init__</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td>
<td class="paramname"><em>id</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Creates a base resource.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>id</em>&nbsp;</td><td> The instance id of the resource.
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="cancelTask"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> cancelTask</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Stops the execution of the current task and continues with the next one.
Additionally an error message is emitted.
</p></div></div><a class="anchor" name="cancelTask"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> cancelTask</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td>
<td class="paramname"><em>error</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Stops the execution of the current task and continues with the next one.
Additionally an error message is emitted.
</p></div></div><a class="anchor" name="changeCommitted"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> changeCommitted</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Item.html">Akonadi.Item</a>&nbsp;</td>
<td class="paramname"><em>item</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Call whenever you have successfully handled or ignored a collection
change notification.
</p>
<p>
This will update the remote identifier of <b>collection</b> if necessary,
as well as any other collection attributes.
This implicitly calls changeProcessed().
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>collection</em>&nbsp;</td><td> The collection which changes have been handled.
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="changeCommitted"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> changeCommitted</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Collection.html">Akonadi.Collection</a>&nbsp;</td>
<td class="paramname"><em>collection</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Call whenever you have successfully handled or ignored a collection
change notification.
</p>
<p>
This will update the remote identifier of <b>collection</b> if necessary,
as well as any other collection attributes.
This implicitly calls changeProcessed().
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>collection</em>&nbsp;</td><td> The collection which changes have been handled.
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="clearCache"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> clearCache</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Call this method to remove all items and collections of the resource from the
server cache.
</p>
<p>
The method should be used whenever the configuration of the resource has changed
and therefor the cached items might not be valid any longer.
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.3
</dd></dl>
</p></div></div><a class="anchor" name="collectionsRetrievalDone"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> collectionsRetrievalDone</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Call this method to indicate you finished synchronizing the collection tree.
</p>
<p>
This is not needed if you use the built in syncing without collection streaming
and call collectionsRetrieved() or collectionRetrievedIncremental() instead.
If collection streaming is enabled, call this method once all collections have been delivered
using collectionsRetrieved() or collectionsRetrievedIncremental().
</p></div></div><a class="anchor" name="collectionsRetrieved"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> collectionsRetrieved</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Collection.List.html">Akonadi.Collection.List</a>&nbsp;</td>
<td class="paramname"><em>collections</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Call this to supply the full folder tree retrieved from the remote server.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>collections</em>&nbsp;</td><td> A list of collections.
</td></tr> </table></dl>
<p> <dl class="see" compact><dt><b>See also:</b></dt><dd> collectionsRetrievedIncremental()
</dd></dl>
</p></div></div><a class="anchor" name="collectionsRetrievedIncremental"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> collectionsRetrievedIncremental</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Collection.List.html">Akonadi.Collection.List</a>&nbsp;</td>
<td class="paramname"><em>changedCollections</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Collection.List.html">Akonadi.Collection.List</a>&nbsp;</td>
<td class="paramname"><em>removedCollections</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Call this to supply incrementally retrieved collections from the remote server.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>changedCollections</em>&nbsp;</td><td> Collections that have been added or changed.

<tr><td></td><td valign="top"><em>removedCollections</em>&nbsp;</td><td> Collections that have been deleted.
</td></tr> </table></dl>
<p> <dl class="see" compact><dt><b>See also:</b></dt><dd> collectionsRetrieved()
</dd></dl>
</p></div></div><a class="anchor" name="currentCollection"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="../akonadi/Akonadi.Collection.html">Akonadi.Collection</a> currentCollection</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Returns the collection that is currently synchronized.
</p></div></div><a class="anchor" name="currentItem"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="../akonadi/Akonadi.Item.html">Akonadi.Item</a> currentItem</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Returns the item that is currently retrieved.
</p></div></div><a class="anchor" name="deferTask"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> deferTask</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Stops the execution of the current task and continues with the next one.
The current task will be tried again later.
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.3
</dd></dl>
</p></div></div><a class="anchor" name="doSetOnline"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> doSetOnline</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>online</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Inherited from AgentBase.
</p></div></div><a class="anchor" name="itemRetrieved"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> itemRetrieved</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Item.html">Akonadi.Item</a>&nbsp;</td>
<td class="paramname"><em>item</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Call this method from retrieveItem() once the result is available.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>item</em>&nbsp;</td><td> The retrieved item.
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="itemsRetrievalDone"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> itemsRetrievalDone</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Call this method to indicate you finished synchronizing the current collection.
</p>
<p>
This is not needed if you use the built in syncing without item streaming
and call itemsRetrieved() or itemsRetrievedIncremental() instead.
If item streaming is enabled, call this method once all items have been delivered
using itemsRetrieved() or itemsRetrievedIncremental().
<dl class="see" compact><dt><b>See also:</b></dt><dd> retrieveItems()
</dd></dl>
</p></div></div><a class="anchor" name="itemsRetrieved"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> itemsRetrieved</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Item.List.html">Akonadi.Item.List</a>&nbsp;</td>
<td class="paramname"><em>items</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Call this method to supply the full collection listing from the remote server.
</p>
<p>
If the remote server supports incremental listing, it's strongly
recommended to use itemsRetrievedIncremental() instead.
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>items</em>&nbsp;</td><td> A list of items.
</td></tr> </table></dl>
<p> <dl class="see" compact><dt><b>See also:</b></dt><dd> itemsRetrievedIncremental().
</dd></dl>
</p></div></div><a class="anchor" name="itemsRetrievedIncremental"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> itemsRetrievedIncremental</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Item.List.html">Akonadi.Item.List</a>&nbsp;</td>
<td class="paramname"><em>changedItems</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Item.List.html">Akonadi.Item.List</a>&nbsp;</td>
<td class="paramname"><em>removedItems</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Call this method to supply incrementally retrieved items from the remote server.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>changedItems</em>&nbsp;</td><td> Items changed in the backend.

<tr><td></td><td valign="top"><em>removedItems</em>&nbsp;</td><td> Items removed from the backend.
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="name"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a> name</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Returns the name of the resource.
</p></div></div><a class="anchor" name="nameChanged"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> nameChanged</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td>
<td class="paramname"><em>name</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>This signal is emitted whenever the name of the resource has changed.
</p>
<p>
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>name</em>&nbsp;</td><td> The new name of the resource.
</td></tr>
</table></dl>
<p>
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("nameChanged(const QString&)"), target_slot)</code></dd></dl></div></div><a class="anchor" name="retrieveCollections"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> retrieveCollections</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><dl compact><dt><b>Abstract method:</b></dt><dd>This method is abstract and can be overridden but not called directly.</dd></dl><p>Retrieve the collection tree from the remote server and supply it via
collectionsRetrieved() or collectionsRetrievedIncremental().
<dl class="see" compact><dt><b>See also:</b></dt><dd> collectionsRetrieved(), collectionsRetrievedIncremental()
</dd></dl>
</p></div></div><a class="anchor" name="retrieveItem"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname">bool retrieveItem</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Item.html">Akonadi.Item</a>&nbsp;</td>
<td class="paramname"><em>item</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">QSet<QByteArray>&nbsp;</td>
<td class="paramname"><em>parts</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><dl compact><dt><b>Abstract method:</b></dt><dd>This method is abstract and can be overridden but not called directly.</dd></dl><p>Retrieve a single item from the backend. The item to retrieve is provided as <b>item.</b>
Add the requested payload parts and call itemRetrieved() when done.
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>item</em>&nbsp;</td><td> The empty item whose payload should be retrieved. Use this object when delivering
the result instead of creating a new item to ensure conflict detection will work.

<tr><td></td><td valign="top"><em>parts</em>&nbsp;</td><td> The item parts that should be retrieved.
</td></tr> </table></dl>
<p> <dl class="return" compact><dt><b>Returns:</b></dt><dd> false if there is an immediate error when retrieving the item.
</dd></dl> <dl class="see" compact><dt><b>See also:</b></dt><dd> itemRetrieved()
</dd></dl>
</p></div></div><a class="anchor" name="retrieveItems"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> retrieveItems</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.Collection.html">Akonadi.Collection</a>&nbsp;</td>
<td class="paramname"><em>collection</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><dl compact><dt><b>Abstract method:</b></dt><dd>This method is abstract and can be overridden but not called directly.</dd></dl><p>Retrieve all (new/changed) items in collection <b>collection.</b>
It is recommended to use incremental retrieval if the backend supports that
and provide the result by calling itemsRetrievedIncremental().
If incremental retrieval is not possible, provide the full listing by calling
itemsRetrieved( const Item.List&amp; ).
In any case, ensure that all items have a correctly set remote identifier
to allow synchronizing with items already existing locally.
In case you don't want to use the built-in item syncing code, store the retrieved
items manually and call itemsRetrieved() once you are done.
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>collection</em>&nbsp;</td><td> The collection whose items to retrieve.
</td></tr> </table></dl>
<p> <dl class="see" compact><dt><b>See also:</b></dt><dd> itemsRetrieved( const Item.List&amp; ), itemsRetrievedIncremental(), itemsRetrieved(), currentCollection()
</dd></dl>
</p></div></div><a class="anchor" name="scheduleCustomTask"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> scheduleCustomTask</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qobject.html">QObject</a>&nbsp;</td>
<td class="paramname"><em>receiver</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td>
<td class="paramname"><em>method</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qvariant.html">QVariant</a>&nbsp;</td>
<td class="paramname"><em>argument</em>, </td>
</tr>
<tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="../akonadi/Akonadi.ResourceBase.html#SchedulePriority">Akonadi.ResourceBase.SchedulePriority</a>&nbsp;</td>
<td class="paramname"><em>priority</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Schedules a custom task in the internal scheduler. It will be queued with
all other tasks such as change replays and retrieval requests and eventually
executed by calling the specified method. With the priority parameter the
time of execution of the Task can be influenced. <dl class="see" compact><dt><b>See also:</b></dt><dd> SchedulePriority
</dd></dl> </p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>receiver</em>&nbsp;</td><td> The object the slot should be called on.

<tr><td></td><td valign="top"><em>methodName</em>&nbsp;</td><td> The name of the method (and only the name, not signature, not SLOT(...) macro),
that should be called to execute this task. The method has to be a slot and take a QVariant as
argument.

<tr><td></td><td valign="top"><em>argument</em>&nbsp;</td><td> A QVariant argument passed to the method specified above. Use this to pass task
parameters.

<tr><td></td><td valign="top"><em>priority</em>&nbsp;</td><td> Priority of the task. Use this to influence the position in
the execution queue.
</td></tr> </table></dl>
<p> <dl class="since" compact><dt><b>Since:</b></dt><dd> 4.4
</dd></dl>
</p></div></div><a class="anchor" name="setCollectionStreamingEnabled"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> setCollectionStreamingEnabled</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>enable</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Enable collection streaming, that is collections don't have to be delivered at once
as result of a retrieveCollections() call but can be delivered by multiple calls
to collectionsRetrieved() or collectionsRetrievedIncremental(). When all collections
have been retrieved, call collectionsRetrievalDone().
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>enable</em>&nbsp;</td><td> true if collection streaming should be enabled, false by default
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="setHierarchicalRemoteIdentifiersEnabled"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> setHierarchicalRemoteIdentifiersEnabled</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>enable</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Indicate the use of hierarchical remote identifiers.
</p>
<p>
This means that it is possible to have two different items with the same
remoteId in different Collections.
</p>
<p>
This should be called in the resource constructor as needed.
</p>
<p>
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.4
</dd></dl>
</p></div></div><a class="anchor" name="setItemStreamingEnabled"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> setItemStreamingEnabled</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">bool&nbsp;</td>
<td class="paramname"><em>enable</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Enable item streaming.
Item streaming is disabled by default.
</p><dl compact><dt><b>Parameters:</b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td></td><td valign="top"><em>enable</em>&nbsp;</td><td> true if items are delivered in chunks rather in one big block.
</td></tr>
</table></dl>
<p>
</p></div></div><a class="anchor" name="setName"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> setName</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype"><a href="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/qstring.html">QString</a>&nbsp;</td>
<td class="paramname"><em>name</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>This method is used to set the name of the resource.
</p></div></div><a class="anchor" name="setTotalItems"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> setTotalItems</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">int&nbsp;</td>
<td class="paramname"><em>amount</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>Call this method when you want to use the itemsRetrieved() method
in streaming mode and indicate the amount of items that will arrive
that way.
<dl class="deprecated" compact><dt><b>Deprecated:</b></dt><dd> Use setItemStreamingEnabled( true ) + itemsRetrieved[Incremental]()
+ itemsRetrieved() instead.
</dd></dl>
</p></div></div><a class="anchor" name="synchronize"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> synchronize</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>This method is called whenever the resource should start synchronize all data.
</p></div></div><a class="anchor" name="synchronizeCollection"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> synchronizeCollection</td>
<td>(</td>
<td class="paramtype">&nbsp;<em>self</em>, </td>
<td class="paramname"></td>
</tr><tr>
<td class="memname"></td>
<td></td>
<td class="paramtype">long&nbsp;</td>
<td class="paramname"><em>id</em></td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td>
<td></td>
<td width="100%"> </td>
</tr></table>
</div>
<div class="memdoc"><p>This method is called whenever the collection with the given <b>id</b>
shall be synchronized.
</p></div></div><a class="anchor" name="synchronizeCollectionTree"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> synchronizeCollectionTree</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Refetches the Collections.
</p></div></div><a class="anchor" name="synchronized"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> synchronized</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Emitted when a full synchronization has been completed.
</p><dl compact><dt><b>Signal syntax:</b></dt><dd><code>QObject.connect(source, SIGNAL("synchronized()"), target_slot)</code></dd></dl></div></div><a class="anchor" name="taskDone"></a>
<div class="memitem">
<div class="memproto">
<table class="memname"><tr>
<td class="memname"> taskDone</td>
<td>(</td>
<td class="paramtype">&nbsp;</td>
<td class="paramname"><em>self</em>&nbsp;)</td>
<td width="100%"> </td>
</tr>
</table>
</div>
<div class="memdoc"><p>Indicate that the current task is finished. Use this method from the slot called via scheduleCustomTaks().
As with all the other callbacks, make sure to either call taskDone() or cancelTask()/deferTask() on all
exit paths, otherwise the resource will hang.
<dl class="since" compact><dt><b>Since:</b></dt><dd> 4.4
</dd></dl>
</p></div></div><hr><h2>Enumeration Documentation</h2><a class="anchor" name="SchedulePriority"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr><td class="memname">SchedulePriority</td>
</tr>
</table>
</div>
<div class="memdoc"><p>Describes the scheduling priority of a task that has been queued
for execution.
</p>
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd> scheduleCustomTask
</dd></dl> <dl class="since" compact><dt><b>Since:</b></dt><dd> 4.4
</dd></dl>
</p><dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0"><tr><td valign="top"><em>Prepend</em>&nbsp;</td><td><tr><td valign="top"><em>AfterChangeReplay</em>&nbsp;</td><td><tr><td valign="top"><em>Append</em>&nbsp;</td><td></table>
</dl>
</div></div><p>
</div>
</div>
</div>

<div id="left">

<div class="menu_box">
<div class="nav_list">
<ul>
<li><a href="../allclasses.html">Full Index</a></li>
</ul>
</div>

<a name="cp-menu" /><div class="menutitle"><div>
  <h2 id="cp-menu-project">Modules</h2>
</div></div>
<div class="nav_list">
<ul><li><a href="../akonadi/index.html">akonadi</a></li>
<li><a href="../dnssd/index.html">dnssd</a></li>
<li><a href="../kdecore/index.html">kdecore</a></li>
<li><a href="../kdeui/index.html">kdeui</a></li>
<li><a href="../khtml/index.html">khtml</a></li>
<li><a href="../kio/index.html">kio</a></li>
<li><a href="../knewstuff/index.html">knewstuff</a></li>
<li><a href="../kparts/index.html">kparts</a></li>
<li><a href="../kutils/index.html">kutils</a></li>
<li><a href="../nepomuk/index.html">nepomuk</a></li>
<li><a href="../phonon/index.html">phonon</a></li>
<li><a href="../plasma/index.html">plasma</a></li>
<li><a href="../polkitqt/index.html">polkitqt</a></li>
<li><a href="../solid/index.html">solid</a></li>
<li><a href="../soprano/index.html">soprano</a></li>
</ul></div></div>

</div>

</div>
  <div class="clearer"/>
</div>

<div id="end_body"></div>
</div>
<div id="footer"><div id="footer_text">
This documentation is maintained by <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;simon&#64;simonzone&#46;com">Simon Edwards</a>.<br />
        KDE<sup>&#174;</sup> and <a href="../images/kde_gear_black.png">the K Desktop Environment<sup>&#174;</sup> logo</a> are registered trademarks of <a href="http://ev.kde.org/" title="Homepage of the KDE non-profit Organization">KDE e.V.</a> |
        <a href="http://www.kde.org/contact/impressum.php">Legal</a>
    </div></div>
</body>
</html>
