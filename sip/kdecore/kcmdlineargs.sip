//
//     Copyright 2008 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2007 Jim Bublitz also apply

//                 Generated by twine

// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


class KCmdLineOptions
{
%TypeHeaderCode
#include <kcmdlineargs.h>
extern char **pyArgvToC(PyObject *argvlist,int *argcp);
extern void updatePyArgv(PyObject *argvlist,int argc,char **argv);
%End


public:
                            KCmdLineOptions ();
                            KCmdLineOptions (const KCmdLineOptions& options);
    KCmdLineOptions&        add (const QByteArray& name, const KLocalizedString& description = KLocalizedString(), const QByteArray& defaultValue = QByteArray());
    KCmdLineOptions&        add (const KCmdLineOptions& options);
    ~KCmdLineOptions ();
};
// KCmdLineOptions


class KCmdLineArgs
{
%TypeHeaderCode
#include <kcmdlineargs.h>
#include <qapplication.h>
extern char **pyArgvToC(PyObject *argvlist,int *argcp);
extern void updatePyArgv(PyObject *argvlist,int argc,char **argv);
%End



public:
    enum StdCmdLineArg
    {
        CmdLineArgQt,
        CmdLineArgKDE,
        CmdLineArgsMask,
        CmdLineArgNone,
        Reserved
    };

    typedef QFlags<KCmdLineArgs::StdCmdLineArg> StdCmdLineArgs;

//force
    static void             init (SIP_PYLIST argv, const QByteArray& appname, const QByteArray& catalog, const KLocalizedString& programName, const QByteArray& version, const KLocalizedString& description = KLocalizedString(), int stdargs = 3) [void (int, char**, const QByteArray&, const QByteArray&, const KLocalizedString&, const QByteArray&, const KLocalizedString& = KLocalizedString(), KCmdLineArgs::StdCmdLineArgs = 3)];
%MethodCode
KCmdLineArgs::StdCmdLineArgs cmdLineArgs = (KCmdLineArgs::StdCmdLineArgs) a6;
    int argc, nargc;
    char **argv;
      
    // Convert the list.

    if ((argv = pyArgvToC(a0, &argc)) == NULL)
        return NULL;

    // Create it now the arguments are right.
    nargc = argc;

    Py_BEGIN_ALLOW_THREADS
    KCmdLineArgs::init (nargc, argv, *a1, *a2, *a3, *a4, *a5, cmdLineArgs);
    Py_END_ALLOW_THREADS

    // Now modify the original list.

    updatePyArgv (a0, argc, argv);
%End

    static void             init (SIP_PYLIST argv, const KAboutData* about, int stdargs = 3) [void (int, char**, const KAboutData*, KCmdLineArgs::StdCmdLineArgs = 3)];
%MethodCode
KCmdLineArgs::StdCmdLineArgs cmdLineArgs = (KCmdLineArgs::StdCmdLineArgs) a2;
    int argc, nargc;
    char **argv;
       
    // Convert the list.

    if ((argv = pyArgvToC(a0, &argc)) == NULL)
        return NULL;

    // Create it now the arguments are right.
    nargc = argc;

    Py_BEGIN_ALLOW_THREADS
    KCmdLineArgs::init (nargc, argv, a1, cmdLineArgs);
    Py_END_ALLOW_THREADS

    // Now modify the original list.

    updatePyArgv (a0, argc, argv);
%End
//end
    static void             init (const KAboutData* about);
    static void             addStdCmdLineOptions (KCmdLineArgs::StdCmdLineArgs stdargs = KCmdLineArgs::StdCmdLineArgs(KCmdLineArgs::CmdLineArgQt|KCmdLineArgs::CmdLineArgKDE));
    static void             addCmdLineOptions (const KCmdLineOptions& options, const KLocalizedString& name = KLocalizedString(), const QByteArray& id = QByteArray(), const QByteArray& afterId = QByteArray());
    static KCmdLineArgs*    parsedArgs (const QByteArray& id = QByteArray());
    static QString          cwd ();
    static QString          appName ();
    static void             usage (const QByteArray& id = QByteArray());
    static void             usageError (const QString& error);
    static void             enable_i18n ();
    QString                 getOption (const QByteArray& option) const;
    QStringList             getOptionList (const QByteArray& option) const;
    bool                    isSet (const QByteArray& option) const;
    int                     count () const;
    QString                 arg (int n) const;
    KUrl                    url (int n) const;
    static KUrl             makeURL (const QByteArray& urlArg);
    static void             setCwd (const QByteArray& cwd);
    void                    clear ();
    static void             reset ();
    static void             loadAppArgs (QDataStream&);

    static void             saveAppArgs (QDataStream&);

    static void             addTempFileOption ();
    static bool             isTempFileSet ();
//ig    static int&             qtArgc ();
//ig    static char**           qtArgv ();
    static const KAboutData*  aboutData ();

protected:
                            KCmdLineArgs (const KCmdLineOptions& _options, const KLocalizedString& _name, const QByteArray& _id);
    ~KCmdLineArgs ();

private:
//force
                            KCmdLineArgs (const KCmdLineArgs& other);
//end
public:
//ig    static void             init (int argc, char** argv, const QByteArray& appname, const QByteArray& catalog, const KLocalizedString& programName, const QByteArray& version, const KLocalizedString& description = KLocalizedString(), KCmdLineArgs::StdCmdLineArgs stdargs = StdCmdLineArgs(CmdLineArgQt|CmdLineArgKDE));
//ig    static void             init (int _argc, char** _argv, const KAboutData* about, KCmdLineArgs::StdCmdLineArgs stdargs = StdCmdLineArgs(CmdLineArgQt|CmdLineArgKDE));
    static QStringList      allArguments ();
};
// KCmdLineArgs



%ModuleCode
#include <string.h>

// Convert a Python argv list to a conventional C argc count and argv array.
char **pyArgvToC(PyObject *argvlist,int *argcp)
{
    int argc;
    char **argv;

    argc = PyList_Size(argvlist);

    // Allocate space for two copies of the argument pointers, plus the
    // terminating NULL.
    if ((argv = (char **)sipMalloc(2 * (argc + 1) * sizeof (char *))) == NULL)
        return NULL;

    // Convert the list.
    for (int a = 0; a < argc; ++a)
    {
        char *arg;
#if PY_MAJOR_VERSION >= 3
        PyObject *utf8bytes = PyUnicode_AsUTF8String(PyList_GetItem(argvlist,a));
        arg = PyBytes_AsString(utf8bytes);
#else
        arg = PyString_AsString(PyList_GetItem(argvlist,a));
#endif   
        // Get the argument and allocate memory for it.
        if (arg == NULL || (argv[a] = (char *)sipMalloc(strlen(arg) + 1)) == NULL)
            return NULL;

        // Copy the argument and save a pointer to it.
        strcpy(argv[a],arg);
        argv[a + argc + 1] = argv[a];
#if PY_MAJOR_VERSION >= 3
        Py_DECREF(utf8bytes);
#endif        
    }

    argv[argc + argc + 1] = argv[argc] = NULL;

    *argcp = argc;

    return argv;
}


// Remove arguments from the Python argv list that have been removed from the
// C argv array.
void updatePyArgv(PyObject *argvlist,int argc,char **argv)
{
    for (int a = 0, na = 0; a < argc; ++a)
    {
        // See if it was removed.
        if (argv[na] == argv[a + argc + 1])
            ++na;
        else
            PyList_SetSlice(argvlist,na,na + 1,NULL);
    }
}
%End

