//
//     Copyright 2007 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2006 Jim Bublitz also apply


//                 Generated by preSip
//            PyKDE4 module kdecore  version KDE 3.92.0


// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

%ModuleHeaderCode
//ctscc
#include <kurl.h>
%End


class KUrl : QUrl
{
%TypeHeaderCode
#include <kurl.h>
%End


public:
    typedef QMap<QString, QString> MetaDataMap;

    enum MimeDataFlags
    {
        DefaultMimeDataFlags, 
        NoTextExport
    };


    class List
    {

    public:
                             List ();
                             List (const KUrl&);
                             List (const QStringList&);
        QStringList          toStringList () const;
//ig                              operator QVariant () const;
        void                 populateMimeData (QMimeData*, const KUrl::MetaDataMap& = KUrl::MetaDataMap (), KUrl::MimeDataFlags = KUrl::DefaultMimeDataFlags ) const;
        static bool          canDecode (const QMimeData*);
        static QStringList   mimeDataTypes ();
        static KUrl::List    fromMimeData (const QMimeData*, KUrl::MetaDataMap* = 0);

    public:
//force
        int                  __len__ ()  /NonLazy/;
%MethodCode
//returns (int)
    Py_BEGIN_ALLOW_THREADS
    sipRes = sipCpp -> count();
    Py_END_ALLOW_THREADS
%End

        void                 __setitem__ (int, const KUrl&);
%MethodCode
//takes index | (int) | value | (KUrl)
    int len;

    len = sipCpp -> count();

    if ((a0 = sipConvertFromSequenceIndex(a0,len)) < 0)
        sipIsErr = 1;
    else
        (*sipCpp)[a0] = *a1;
%End

        void                 __setitem__ (SIP_PYSLICE, const KUrl::List&);
%MethodCode
//takes range | (a Python slice) | urlList | (KUrl.List)
    SIP_SSIZE_T len, start, stop, step, slicelength, i;

    len = sipCpp -> count();

    if (sipConvertFromSliceObject(a0,len,&start,&stop,&step,&slicelength) < 0)
        sipIsErr = 1;
    else
    {
        int vlen = a1 -> count();
        if (vlen != slicelength)
        {
            sipBadLengthForSlice(vlen,slicelength);
            sipIsErr = 1;
        }
        else
        {
            KUrl::List::ConstIterator it = a1 -> begin();
            for (i = 0; i < slicelength; ++i)
            {
                (*sipCpp)[start] = *it;
                start += step;
                ++it;
            }
        }
    }
%End

        void                 __delitem__ (int);
%MethodCode
//takes index | (int)
    int len;

    len = sipCpp -> count();

    if ((a0 = sipConvertFromSequenceIndex(a0,len)) < 0)
        sipIsErr = 1;
    else
        sipCpp -> removeAt(a0);
%End

        void                 __delitem__ (SIP_PYSLICE);
%MethodCode
//takes range | (a Python slice)
    
    SIP_SSIZE_T len, start, stop, step, slicelength, i;

    len = sipCpp -> count();
    if (sipConvertFromSliceObject(a0,len,&start,&stop,&step,&slicelength) < 0)
        sipIsErr = 1;
    else
        for (i = 0; i < slicelength; ++i)
        {
            sipCpp -> removeAt(start);
            start += step - 1;
        }
%End

        KUrl                 operator [] (int);
%MethodCode
//returns (KUrl)
//takes index | (int)
    int len;

    len = sipCpp -> count();

    if ((a0 = sipConvertFromSequenceIndex(a0,len)) < 0)
        sipIsErr = 1;
    else
        sipRes = new KUrl((*sipCpp)[a0]);
%End

        KUrl::List           operator [] (SIP_PYSLICE);
%MethodCode
//returns (KUrl.List)
//takes range | (a Python slice)

    SIP_SSIZE_T len, start, stop, step, slicelength, i;

    len = sipCpp -> count();

    if (sipConvertFromSliceObject(a0,len,&start,&stop,&step,&slicelength) < 0)
        sipIsErr = 1;
    else
    {
        sipRes = new KUrl::List();

        for (i = 0; i < slicelength; ++i)
        {
            (*sipRes) += (*sipCpp)[start];
            start += step;
        }
    }
%End

        KUrl::List           operator + (const KUrl::List&);
%MethodCode
//returns (KUrl.List)
//takes listToAdd | (KUrl.List)
    Py_BEGIN_ALLOW_THREADS
//    sipRes = new KUrl::List((const KUrl::List&)((*sipCpp) + *a0));
    sipRes = new KUrl::List (*sipCpp);
    (*sipRes) += (*a0);
    Py_END_ALLOW_THREADS
%End

        KUrl::List&          operator += (const KUrl::List&);
        KUrl::List           operator * (int);
%MethodCode
    sipRes = new KUrl::List();

    for (int i = 0; i < a0; ++i)
        (*sipRes) += (*sipCpp);
%End

        KUrl::List&          operator *= (int);
%MethodCode
//returns (KUrl.List)
//takes val | (int)
    KUrl::List orig(*sipCpp);

    sipCpp -> clear();

    for (int i = 0; i < a0; ++i)
        (*sipCpp) += orig;
%End

        bool                 operator == (const KUrl::List&);
        bool                 operator != (const KUrl::List&);
        int                  __contains__ (KUrl)  /NonLazy/;
%MethodCode
//returns (bool)
//takes a0 | (KUrl)
        // It looks like you can't assign QBool to int.
        sipRes = bool(sipCpp->contains(*a0));
%End

//end


    };  // class List


public:
                         KUrl ();
                         KUrl (const QString&);
                         KUrl (const char*);
                         KUrl (const QByteArray&);
                         KUrl (const KUrl&);
                         KUrl (const QUrl&);
                         KUrl (const KUrl&, const QString&);
    QString              protocol () const;
    void                 setProtocol (const QString&);
    QString              user () const;
    void                 setUser (const QString&);
    bool                 hasUser () const;
    QString              pass () const /PyName=pass_/;
    void                 setPass (const QString&);
    bool                 hasPass () const;
    bool                 hasHost () const;

    enum AdjustPathOption
    {
        RemoveTrailingSlash, 
        LeaveTrailingSlash, 
        AddTrailingSlash
    };

    QString              path (KUrl::AdjustPathOption) const;
    QString              toLocalFile (KUrl::AdjustPathOption = KUrl::LeaveTrailingSlash ) const;
    void                 setPath (const QString&);
    bool                 hasPath () const;

    enum CleanPathOption
    {
        SimplifyDirSeparators, 
        KeepDirSeparators
    };

    typedef QFlags<KUrl::CleanPathOption> CleanPathOptions;
    void                 cleanPath (const KUrl::CleanPathOption& = KUrl::SimplifyDirSeparators );
    void                 adjustPath (KUrl::AdjustPathOption);
    void                 setEncodedPathAndQuery (const QString&);

    enum EncodedPathAndQueryOption
    {
        PermitEmptyPath, 
        AvoidEmptyPath
    };

    typedef QFlags<KUrl::EncodedPathAndQueryOption> EncodedPathAndQueryOptions;
    QString              encodedPathAndQuery (KUrl::AdjustPathOption = KUrl::LeaveTrailingSlash , const KUrl::EncodedPathAndQueryOptions& = KUrl::PermitEmptyPath ) const;
    void                 setQuery (const QString&);
    QString              query () const;
    QString              ref () const;
    void                 setRef (const QString&);
    bool                 hasRef () const;
    QString              htmlRef () const;
    QString              encodedHtmlRef () const;
    void                 setHTMLRef (const QString&);
    bool                 hasHTMLRef () const;
    bool                 isLocalFile () const;
    void                 setFileEncoding (const QString&);
    QString              fileEncoding () const;
    bool                 hasSubUrl () const;
    void                 addPath (const QString&);

    enum QueryItemsOption
    {
        CaseInsensitiveKeys
    };

    typedef QFlags<KUrl::QueryItemsOption> QueryItemsOptions;
    QMap<QString, QString> queryItems (const KUrl::QueryItemsOptions& = 0) const;
    QString              queryItem (const QString&) const;
    void                 addQueryItem (const QString&, const QString&);
    void                 setFileName (const QString&);

    enum DirectoryOption
    {
        ObeyTrailingSlash, 
        AppendTrailingSlash, 
        IgnoreTrailingSlash
    };

    typedef QFlags<KUrl::DirectoryOption> DirectoryOptions;
    QString              fileName (const KUrl::DirectoryOptions& = KUrl::IgnoreTrailingSlash ) const;
    QString              directory (const KUrl::DirectoryOptions& = KUrl::IgnoreTrailingSlash ) const;
    void                 setDirectory (const QString&);
    bool                 cd (const QString&);
    QString              url (KUrl::AdjustPathOption = KUrl::LeaveTrailingSlash ) const;
    QString              prettyUrl (KUrl::AdjustPathOption = KUrl::LeaveTrailingSlash ) const;
    QString              pathOrUrl () const;
    QString              toMimeDataString () const;
    KUrl                 upUrl () const;
    bool                 operator == (const KUrl&) const;
    bool                 operator == (const QString&) const;
    bool                 operator != (const KUrl&) const;
    bool                 operator != (const QString&) const;
//ig                          operator QVariant () const;
    bool                 cmp (const KUrl&, bool = 0) const;

    enum EqualsOption
    {
        CompareWithoutTrailingSlash, 
        CompareWithoutFragment
    };

    typedef QFlags<KUrl::EqualsOption> EqualsOptions;
    bool                 equals (const KUrl&, const KUrl::EqualsOptions& = 0) const;
    bool                 isParentOf (const KUrl&) const;
    static List          split (const QString&);
    static List          split (const KUrl&);
    static KUrl          join (const List&);
    static KUrl          fromPath (const QString&);
    static KUrl          fromPathOrUrl (const QString&);
    static KUrl          fromMimeDataByteArray (const QByteArray&);
    void                 populateMimeData (QMimeData*, const KUrl::MetaDataMap& = KUrl::MetaDataMap (), KUrl::MimeDataFlags = KUrl::DefaultMimeDataFlags ) const;
    static QString       encode_string (const QString&);
    static QString       encode_string_no_slash (const QString&);
    static QString       decode_string (const QString&);
    static bool          isRelativeUrl (const QString&);
    static QString       relativeUrl (const KUrl&, const KUrl&);
    static QString       relativePath (const QString&, const QString&, bool* /Out/);

private:
//igx                          operator QString () const;

// Subclasses for QUrl

public:
%ConvertToSubClassCode

    if (dynamic_cast<KUrl*>(sipCpp))
        sipClass = sipClass_KUrl;
    else
        sipClass = NULL;
%End


};  // class KUrl

bool                 urlcmp (const QString&, const QString&);
bool                 urlcmp (const QString&, const QString&, const KUrl::EqualsOptions&);
uint                 qHash (const QString&);
