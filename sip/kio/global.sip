//
//     Copyright 2008 Jim Bublitz <jbublitz@nwinternet.com>
//     Earlier copyrights 1998 - 2007 Jim Bublitz also apply

//                 Generated by twine

// This file is part of PyKDE4.

// PyKDE4 is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of
// the License, or (at your option) any later version.

// PyKDE4 is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

%ModuleHeaderCode
#include <global.h>
%End

namespace KIO
{
typedef qlonglong fileoffset_t;

typedef qulonglong filesize_t;

QString                 convertSize (KIO::filesize_t size);
QString                 number (KIO::filesize_t size);
QString                 convertSizeFromKiB (KIO::filesize_t kibSize);
unsigned int            calculateRemainingSeconds (KIO::filesize_t totalSize, KIO::filesize_t processedSize, KIO::filesize_t speed);
QString                 convertSeconds (unsigned int seconds);
QTime                   calculateRemaining (KIO::filesize_t totalSize, KIO::filesize_t processedSize, KIO::filesize_t speed);
QString                 itemsSummaryString (uint items, uint files, uint dirs, KIO::filesize_t size, bool showSize);
QString                 encodeFileName (const QString& str);
QString                 decodeFileName (const QString& str);

enum Command
{
    CMD_HOST,
    CMD_CONNECT,
    CMD_DISCONNECT,
    CMD_SLAVE_STATUS,
    CMD_SLAVE_CONNECT,
    CMD_SLAVE_HOLD,
    CMD_NONE,
    CMD_TESTDIR,
    CMD_GET,
    CMD_PUT,
    CMD_STAT,
    CMD_MIMETYPE,
    CMD_LISTDIR,
    CMD_MKDIR,
    CMD_RENAME,
    CMD_COPY,
    CMD_DEL,
    CMD_CHMOD,
    CMD_SPECIAL,
    CMD_SETMODIFICATIONTIME,
    CMD_REPARSECONFIGURATION,
    CMD_META_DATA,
    CMD_SYMLINK,
    CMD_SUBURL,
    CMD_MESSAGEBOXANSWER,
    CMD_RESUMEANSWER,
    CMD_CONFIG,
    CMD_MULTI_GET,
    CMD_SETLINKDEST,
    CMD_OPEN,
    CMD_CHOWN,
    CMD_READ,
    CMD_WRITE,
    CMD_SEEK,
    CMD_CLOSE,
    CMD_HOST_INFO
};


enum Error
{
    ERR_CANNOT_OPEN_FOR_READING,
    ERR_CANNOT_OPEN_FOR_WRITING,
    ERR_CANNOT_LAUNCH_PROCESS,
    ERR_INTERNAL,
    ERR_MALFORMED_URL,
    ERR_UNSUPPORTED_PROTOCOL,
    ERR_NO_SOURCE_PROTOCOL,
    ERR_UNSUPPORTED_ACTION,
    ERR_IS_DIRECTORY,
    ERR_IS_FILE,
    ERR_DOES_NOT_EXIST,
    ERR_FILE_ALREADY_EXIST,
    ERR_DIR_ALREADY_EXIST,
    ERR_UNKNOWN_HOST,
    ERR_ACCESS_DENIED,
    ERR_WRITE_ACCESS_DENIED,
    ERR_CANNOT_ENTER_DIRECTORY,
    ERR_PROTOCOL_IS_NOT_A_FILESYSTEM,
    ERR_CYCLIC_LINK,
    ERR_USER_CANCELED,
    ERR_CYCLIC_COPY,
    ERR_COULD_NOT_CREATE_SOCKET,
    ERR_COULD_NOT_CONNECT,
    ERR_CONNECTION_BROKEN,
    ERR_NOT_FILTER_PROTOCOL,
    ERR_COULD_NOT_MOUNT,
    ERR_COULD_NOT_UNMOUNT,
    ERR_COULD_NOT_READ,
    ERR_COULD_NOT_WRITE,
    ERR_COULD_NOT_BIND,
    ERR_COULD_NOT_LISTEN,
    ERR_COULD_NOT_ACCEPT,
    ERR_COULD_NOT_LOGIN,
    ERR_COULD_NOT_STAT,
    ERR_COULD_NOT_CLOSEDIR,
    ERR_COULD_NOT_MKDIR,
    ERR_COULD_NOT_RMDIR,
    ERR_CANNOT_RESUME,
    ERR_CANNOT_RENAME,
    ERR_CANNOT_CHMOD,
    ERR_CANNOT_DELETE,
    ERR_SLAVE_DIED,
    ERR_OUT_OF_MEMORY,
    ERR_UNKNOWN_PROXY_HOST,
    ERR_COULD_NOT_AUTHENTICATE,
    ERR_ABORTED,
    ERR_INTERNAL_SERVER,
    ERR_SERVER_TIMEOUT,
    ERR_SERVICE_NOT_AVAILABLE,
    ERR_UNKNOWN,
    ERR_UNKNOWN_INTERRUPT,
    ERR_CANNOT_DELETE_ORIGINAL,
    ERR_CANNOT_DELETE_PARTIAL,
    ERR_CANNOT_RENAME_ORIGINAL,
    ERR_CANNOT_RENAME_PARTIAL,
    ERR_NEED_PASSWD,
    ERR_CANNOT_SYMLINK,
    ERR_NO_CONTENT,
    ERR_DISK_FULL,
    ERR_IDENTICAL_FILES,
    ERR_SLAVE_DEFINED,
    ERR_UPGRADE_REQUIRED,
    ERR_POST_DENIED,
    ERR_COULD_NOT_SEEK,
    ERR_CANNOT_SETTIME,
    ERR_CANNOT_CHOWN
};

QString                 buildErrorString (int errorCode, const QString& errorText);
//ig QString            buildHTMLErrorString (int errorCode, const QString& errorText, const KUrl* reqUrl = 0, int method = -1);
QByteArray              rawErrorDetail (int errorCode, const QString& errorText, const KUrl* reqUrl = 0, int method = -1);
QString                 unsupportedActionErrorString (const QString& protocol, int cmd);

enum CacheControl
{
    CC_CacheOnly,
    CC_Cache,
    CC_Verify,
    CC_Refresh,
    CC_Reload
};

KIO::CacheControl       parseCacheControl (const QString& cacheControl);
QString                 getCacheControlString (KIO::CacheControl cacheControl);
//ig QPixmap            pixmapForUrl (const KUrl& _url, mode_t _mode = 0, KIconLoader::Group _group = KIconLoader::Desktop, int _force_size = 0, int _state = 0, QString* _path = 0);
KJobTrackerInterface*   getJobTracker ();

//ig class MetaData;

};   // KIO



%ModuleHeaderCode
#include <global.h>
%End


%MappedType KIO::MetaData
{
%TypeHeaderCode
#include<qmap.h>
%End

%ConvertFromTypeCode
    // Convert to a Python dict

    if (!sipCpp)
        return PyDict_New();

    PyObject *dict;

    // Create the dictionary.

    if ((dict = PyDict_New()) == NULL)
        return NULL;

    // Get it.

    const QMap<QString,QString> cppmap = *sipCpp;
    QMap<QString,QString>::ConstIterator it;

    for (it = cppmap.begin (); it != cppmap.end (); ++it)
    {
        QString acpp = it.key ();
        QString bcpp = it.value ();
        PyObject *ainst = 0;
        PyObject *binst = 0;
        if (((ainst = sipBuildResult (NULL, "N", new QString (acpp), sipClass_QString)) == NULL)
            || ((binst = sipBuildResult (NULL, "N", new QString (bcpp), sipClass_QString)) == NULL)
            || (PyDict_SetItem (dict, ainst, binst) < 0))
        {
            Py_XDECREF (ainst);
            Py_XDECREF (binst);
            Py_DECREF (dict);
            return NULL;
        }
    }

    return dict;
%End


%ConvertToTypeCode
    // Convert a Python dictionary to a QMap on the heap.

    if (sipIsErr == NULL)
        return PyDict_Check(sipPy);


    QMap<QString,QString> *cppmap = new QMap<QString,QString>;

    PyObject *aelem, *belem;
    SIP_SSIZE_T pos = 0;
    QString *acpp;
    QString *bcpp;

    while (PyDict_Next(sipPy, &pos, &aelem, &belem))
    {
        int iserr = 0;

        acpp = (QString *)sipForceConvertTo_QString (aelem, &iserr);
        bcpp = (QString *)sipForceConvertTo_QString (belem, &iserr);

        if (iserr)
        {
            *sipIsErr = 1;
            delete cppmap;
            return 0;
        }

        cppmap->insert (*acpp, *bcpp);
    }

    *sipCppPtr = (KIO::MetaData *)cppmap;

    return 1;
%End
};

